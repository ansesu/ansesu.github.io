<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Andre | ansesu</title>
    <link>https://ansesu.github.io/author/andre/</link>
      <atom:link href="https://ansesu.github.io/author/andre/index.xml" rel="self" type="application/rss+xml" />
    <description>Andre</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>pt</language><lastBuildDate>Sat, 05 Jun 2021 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://ansesu.github.io/images/icon_hu1cf0b72f1e483e21040de310180038f0_4688_512x512_fill_lanczos_center_3.png</url>
      <title>Andre</title>
      <link>https://ansesu.github.io/author/andre/</link>
    </image>
    
    <item>
      <title>Visualização de dados com d3.js</title>
      <link>https://ansesu.github.io/post/d3-visualizations/</link>
      <pubDate>Sat, 05 Jun 2021 00:00:00 +0000</pubDate>
      <guid>https://ansesu.github.io/post/d3-visualizations/</guid>
      <description>&lt;script type=&#34;text/javascript&#34; src=&#34;https://d3js.org/d3.v6.min.js&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;js/formatter.js&#34;&gt; &lt;/script&gt;
&lt;link rel=&#34;stylesheet&#34; type=&#34;text/css&#34; href=&#34;css/style.css&#34;&gt;
&lt;p&gt;De acordo com Crameri et al., &amp;ldquo;a representação precisa dos dados é essencial na comunicação científica&amp;rdquo; [1]. De fato, a escolha do tipo mais adequado de visualização de acordo com as características dos dados é imprescindível para comunicar os resultados de uma pesquisa científica. Por exemplo, o gráfico abaixo mostra a evolução temporal do número de reprodução efetivo $R(t)$ referente ao espalhamento da COVID-19 em Maringá. Ao representar valores acima de um, que indicam o aceleramento da propagação do vírus, em vermelho, e valores abaixo de um, que indicam o desaceleramento da propagação, em verde, podemos comunicar visualmente o ritmo de transmissão do vírus.&lt;/p&gt;
&lt;p class=&#34;spacedParagraph&#34;&gt;&lt;p/&gt;
&lt;div id=&#34;thresholdplot&#34; style=&#34;z-index: -1000&#34;&gt;&lt;/div&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;js/simple_threshold_line_plot.js&#34;&gt; &lt;/script&gt;
&lt;p style=&#34;text-align: center&#34; class=&#34;spacedParagraph&#34;&gt;&lt;b&gt;Figura 1&lt;/b&gt;: gráfico de linha com intervalo de confiança e cores diferentes definidas por um limite. Valores acima do limite são coloridos de vermelho, enquanto valores abaixo desse mesmo limite são coloridos de verde. Visualização inspirada no site rt.live.&lt;p/&gt;
&lt;p&gt;O tamanho dos elementos também faz diferença quando representamos dados. A figura abaixo mostra o valor das minhas sequências ouvindo as mesmas faixas de determinado artista ou faixas únicas durante o ano de 2022. O tamanho dos marcadores varia com o tamanho da sequência, comunicando visualmente o tamanho da sequência.&lt;/p&gt;
&lt;p class=&#34;spacedParagraph&#34;&gt;&lt;p/&gt;
&lt;p&gt;&lt;button class=&#34;button&#34; style=&#34;border-radius: 4px; font-size: 1rem;&#34; onclick=&#34;plotStreaks(&#39;data/streak_artist_data.csv&#39;)&#34;&gt;Artista&lt;/button&gt;
&lt;button class=&#34;button&#34; style=&#34;border-radius: 4px; font-size: 1rem;&#34; onclick=&#34;plotStreaks(&#39;data/streak_track_data.csv&#39;)&#34;&gt;Faixa&lt;/button&gt;&lt;/p&gt;
  &lt;div id=&#34;streaks&#34; style=&#34;z-index: -1000&#34;&gt;&lt;/div&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;js/streaks.js&#34;&gt; &lt;/script&gt;
&lt;p style=&#34;text-align: center&#34; class=&#34;spacedParagraph&#34;&gt;&lt;b&gt;Figura 2&lt;/b&gt;: scatter plot com tamanho do marker variável de acordo com valor da variável (com botão para troca de categoria).&lt;p/&gt;
&lt;p&gt;Como mencionado anteriormente, a escolha do tipo de figura de acordo com as características dos dados é essencial. A figura abaixo mostra o volume de faixas dos dez artistas mais ouvidos por mim durante 2022. Nesse contexto, faz sentido utilizar um gráfico de fluxo (stream chart) uma vez que, pela sua utilização, é possível transmitir a ideia de volume.&lt;/p&gt;
&lt;p class=&#34;spacedParagraph&#34;&gt;&lt;p/&gt;
&lt;div id=&#34;stream_chart&#34; style=&#34;z-index: -1000&#34;&gt;&lt;/div&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;js/stream_chart.js&#34;&gt; &lt;/script&gt;
&lt;p style=&#34;text-align: center&#34; class=&#34;spacedParagraph&#34;&gt;&lt;b&gt;Figura 3&lt;/b&gt;: stream chart plot.&lt;p/&gt;
&lt;p&gt;Neste post, apresento algumas figuras confeccionadas por meio do 
&lt;a href=&#34;https://d3js.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;pacote d3.js&lt;/a&gt; e os respectivos tutoriais, além de alguns recursos que podem auxiliar no aprendizado de visualização de dados em geral. O código fonte para os gráficos podem ser acessados 
&lt;a href=&#34;https://github.com/ansesu/ansesu.github.io/tree/master/post/d3-visualizations/js&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;nesta página&lt;/a&gt;.&lt;/p&gt;
&lt;!-- De acordo com o [d3js.org](https://d3js.org/), &#34;esse pacote é uma biblioteca de Javascript para manipular documentos baseados em dados. O D3 ajuda a dar vida aos dados usando HTML, SVG e CSS.&#34;  --&gt;
&lt;!-- A confecção de gráficos e visualizações diretamente por pacotes do Python (ou de qualquer outra linguagem de programação) é muito prática. Porém, existe um limite em relação à interatividade e responsividade quando essas imagens são exibidas em formato da web. Por isso, resolvi aprender um pouquinho sobre a biblioteca [d3.js](https://d3js.org/). Abaixo, mostro algumas visualizações que confeccionei (as figuras são interativas). --&gt;
&lt;h1 id=&#34;gráfico-de-linha&#34;&gt;Gráfico de linha&lt;/h1&gt;
&lt;!-- &lt;div id=&#34;lineplot&#34; style=&#34;z-index: -1000&#34;&gt;&lt;/div&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;js/simple_line_plot.js&#34;&gt; &lt;/script&gt;
&lt;p style=&#34;text-align: center&#34; class=&#34;spacedParagraph&#34;&gt; &lt;b&gt;Figura 1&lt;/b&gt;: gráfico de linha com barra vertical interativa indicando o valor da variável.&lt;p/&gt; --&gt;
&lt;!-- &lt;hr class=&#34;solid&#34;&gt;
`` --&gt;
&lt;!-- 
&lt;div id=&#34;bandplot&#34; style=&#34;z-index: -1000&#34;&gt;&lt;/div&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;js/simple_bandplot.js&#34;&gt; &lt;/script&gt;
&lt;p style=&#34;text-align: center&#34; class=&#34;spacedParagraph&#34;&gt;Figura 2: gráfico de linha com intervalo de confiança e com barra vertical interativa indicando o valor da variável.&lt;p/&gt;

&lt;hr class=&#34;solid&#34;&gt;

&lt;div id=&#34;multilineplot&#34; style=&#34;z-index: -1000&#34;&gt;&lt;/div&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;js/simple_multiline_plot.js&#34;&gt; &lt;/script&gt;
&lt;p style=&#34;text-align: center&#34; class=&#34;spacedParagraph&#34;&gt;Figura 3: gráfico multilinhas com barra vertical interativa indicando o valor das variáveis.&lt;p/&gt;

&lt;hr class=&#34;solid&#34;&gt; --&gt;
&lt;!-- &lt;hr class=&#34;solid&#34;&gt; --&gt;
&lt;!-- &lt;select id=&#34;selectButtonConfirmados&#34;&gt;&lt;/select&gt;
&lt;div id=&#34;comparacao_confirmados&#34; style=&#34;z-index: -1000&#34;&gt;&lt;/div&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;js/comparacao_confirmados.js&#34;&gt; &lt;/script&gt;
&lt;p style=&#34;text-align: center&#34; class=&#34;spacedParagraph&#34;&gt;&lt;b&gt;Figura 3&lt;/b&gt;: gráfico multilinhas (com caixa de seleção para mudança de categoria).&lt;p/&gt; --&gt;
&lt;p&gt;&lt;button class=&#34;button&#34; style=&#34;border-radius: 4px; font-size: 1rem;&#34; onclick=&#34;plotOcupacao(&#39;data/ocupacao.csv&#39;, false, &#39;UTI&#39;, gOcupacao1, &#39;#ocupacao1&#39;, svgOcupacao1); plotOcupacao(&#39;data/ocupacao.csv&#39;, false, &#39;UTI neonatal&#39;, gOcupacao2, &#39;#ocupacao2&#39;, svgOcupacao2); plotOcupacao(&#39;data/ocupacao.csv&#39;, false, &#39;Enfermaria&#39;, gOcupacao3, &#39;#ocupacao3&#39;, svgOcupacao3)&#34;&gt;Total&lt;/button&gt;
&lt;button class=&#34;button&#34; style=&#34;border-radius: 4px; font-size: 1rem;&#34; onclick=&#34;plotOcupacao(&#39;data/ocupacao_covid.csv&#39;, false, &#39;UTI&#39;, gOcupacao1, &#39;#ocupacao1&#39;, svgOcupacao1); plotOcupacao(&#39;data/ocupacao_covid.csv&#39;, false, &#39;UTI neonatal&#39;, gOcupacao2, &#39;#ocupacao2&#39;, svgOcupacao2); plotOcupacao(&#39;data/ocupacao_covid.csv&#39;, false, &#39;Enfermaria&#39;, gOcupacao3, &#39;#ocupacao3&#39;, svgOcupacao3)&#34;&gt;COVID&lt;/button&gt;&lt;/p&gt;
&lt;div style=&#34;padding-bottom: .75rem;&#34;&gt;&lt;/div&gt;
&lt;div id=&#34;ocupacao1&#34; style=&#34;z-index: -1000&#34;&gt;&lt;/div&gt;
&lt;div id=&#34;ocupacao2&#34; style=&#34;z-index: -1000&#34;&gt;&lt;/div&gt;
&lt;div id=&#34;ocupacao3&#34; style=&#34;z-index: -1000&#34;&gt;&lt;/div&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;js/ocupacao.js&#34;&gt; &lt;/script&gt;
&lt;p style=&#34;text-align: center&#34;&gt;&lt;b&gt;Figura 4&lt;/b&gt;: figura com vários paineis (com botão para troca de categoria). Cada painel contém um gráfico de linha preenchido.&lt;p/&gt;
&lt;h1 id=&#34;gráfico-de-barra&#34;&gt;Gráfico de barra&lt;/h1&gt;
&lt;!-- &lt;div id=&#34;simplebarplot&#34; style=&#34;z-index: -1000&#34;&gt;&lt;/div&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;js/simple_barplot.js&#34;&gt; &lt;/script&gt;
&lt;p style=&#34;text-align: center&#34; class=&#34;spacedParagraph&#34;&gt;&lt;b&gt;Figura 6&lt;/b&gt;: gráfico de barras simples.&lt;p/&gt;
 --&gt;
&lt;!-- &lt;hr class=&#34;solid&#34;&gt; --&gt;
&lt;!-- 
&lt;button style=&#34;border-radius: 4px;&#34; onclick=&#34;plotCharts(&#39;../lastfm-2020/data/month_data.csv&#39;, true)&#34;&gt;Mensal&lt;/button&gt;
&lt;button style=&#34;border-radius: 4px;&#34; onclick=&#34; plotCharts(&#39;../lastfm-2020/data/weekday_data.csv&#39;, false)&#34;&gt;Semanal&lt;/button&gt;
  &lt;div id=&#34;barplot&#34; style=&#34;z-index: -1000&#34;&gt;&lt;/div&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;../lastfm-2020/js/months_and_days.js&#34;&gt; &lt;/script&gt;
&lt;p style=&#34;text-align: center&#34; class=&#34;spacedParagraph&#34;&gt;&lt;b&gt;Figura 7&lt;/b&gt;: gráfico de barras agrupado (com botão para troca de categoria).&lt;p/&gt; --&gt;
&lt;!-- &lt;hr class=&#34;solid&#34;&gt; --&gt;
&lt;!-- &lt;div id=&#34;hours&#34; style=&#34;z-index: -1000&#34;&gt;&lt;/div&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;../lastfm-2020/js/hours.js&#34;&gt; &lt;/script&gt;
&lt;p style=&#34;text-align: center&#34; class=&#34;spacedParagraph&#34;&gt;&lt;b&gt;Figura 8&lt;/b&gt;: gráfico de barras radial.&lt;p/&gt;
 --&gt;
&lt;!-- &lt;hr class=&#34;solid&#34;&gt; --&gt;
&lt;script type=&#34;text/javascript&#34;&gt; 
function reloadchart() {
   //alert(&#34;In function&#34;);
   var container = document.getElementById(&#34;barchartrace&#34;);
   //alert(content);
   container.innerHTML= null;  
   makeChart();
  // document.getElementById(&#34;#barchartrace&#34;).reload()
}
&lt;/script&gt;
&lt;p&gt;&lt;button class=&#34;button&#34; style=&#34;border-radius: 4px; font-size: 1rem;&#34; onclick=&#34;reloadchart()&#34;&gt;Reload&lt;/button&gt;&lt;/p&gt;
&lt;div id=&#34;barchartrace&#34; style=&#34;z-index: -1000&#34;&gt; &lt;/div&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;js/barchart_race.js&#34;&gt; &lt;/script&gt;
&lt;p style=&#34;text-align: center&#34; class=&#34;spacedParagraph&#34;&gt;&lt;b&gt;Figura 5&lt;/b&gt;: gráfico de corrida de barras.&lt;p/&gt;
&lt;!-- &lt;hr class=&#34;solid&#34;&gt; --&gt;
&lt;label class=&#34;switch&#34;&gt;
&lt;input type=&#34;checkbox&#34; class=&#34;checkboxConfirmadosDiario&#34; checked&gt; &lt;span class=&#34;slider round&#34;&gt;&lt;/span&gt;&lt;/label&gt; &lt;span style=&#34;font-size: 22px; vertical-align: middle;&#34;&gt; Média móvel &lt;/span&gt;
&lt;div id=&#34;confirmados_diario&#34; style=&#34;z-index: -1000&#34;&gt;&lt;/div&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;js/confirmados_diario.js&#34;&gt; &lt;/script&gt;
&lt;p style=&#34;text-align: center&#34;&gt;&lt;b&gt;Figura 6&lt;/b&gt;: gráfico de barras com média móvel e linha do tempo adjacente (com botão para desativação da média móvel).&lt;p/&gt;
&lt;!-- &lt;div id=&#34;mortes-idade-tempo&#34; style=&#34;z-index: -1000&#34;&gt;&lt;/div&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;js/mortes_idade_tempo.js&#34;&gt; &lt;/script&gt;
&lt;p style=&#34;text-align: center&#34; class=&#34;spacedParagraph&#34;&gt;&lt;b&gt;Figura 12&lt;/b&gt;: gráfico de area empilhado. A legenda é clicável permitindo a visualização de cada área separadamente.&lt;p/&gt; --&gt;
&lt;h1 id=&#34;mapa&#34;&gt;Mapa&lt;/h1&gt;
&lt;p&gt;&lt;button class=&#34;button&#34; style=&#34;border-radius: 4px; font-size: 1rem;&#34; onclick=&#34;plotMap(&#39;cases&#39;, false)&#34;&gt;Casos&lt;/button&gt;
&lt;button class=&#34;button&#34; style=&#34;border-radius: 4px; font-size: 1rem;&#34; onclick=&#34;plotMap(&#39;deaths&#39;, false)&#34;&gt;Mortes&lt;/button&gt;&lt;/p&gt;
&lt;div style=&#34;padding-bottom: .75rem;&#34;&gt;&lt;/div&gt;
&lt;div id=&#34;paranamap&#34; style=&#34;z-index: -1000&#34;&gt;&lt;/div&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;js/simple_map.js&#34;&gt; &lt;/script&gt;
&lt;p style=&#34;text-align: center&#34;&gt;&lt;b&gt;Figura 7&lt;/b&gt;: mapa com escala de cor dependente da amplitude da variável (com botão para troca de categoria).&lt;p/&gt;
&lt;h1 id=&#34;rede&#34;&gt;Rede&lt;/h1&gt;
&lt;div id=&#34;nagoya_subway_network&#34; style=&#34;z-index: -1000&#34;&gt;&lt;/div&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;js/nagoya_subway_network.js&#34;&gt; &lt;/script&gt;
&lt;p style=&#34;text-align: center&#34;&gt;&lt;b&gt;Figura 8&lt;/b&gt;: force-directed graph.&lt;p/&gt;
&lt;h2 id=&#34;recursos&#34;&gt;Recursos&lt;/h2&gt;
&lt;p&gt;- 
&lt;a href=&#34;https://colorbrewer2.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;colorbrewer2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;- 
&lt;a href=&#34;https://github.com/d3/d3-time-format#locale_format&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;d3-time-format&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;- 
&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SVG Attribute reference&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;- 
&lt;a href=&#34;https://observablehq.com/@d3/d3v6-migration-guide&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;D3 6.0 migration guide&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;- 
&lt;a href=&#34;https://chartio.com/resources/tutorials/how-to-resize-an-svg-when-the-window-is-resized-in-d3-js/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;How to Resize an SVG When the Window is Resized in d3.js&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;- 
&lt;a href=&#34;http://bl.ocks.org/williaster/af5b855651ffe29bdca1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Scatterplot with tooltips&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;- 
&lt;a href=&#34;https://bl.ocks.org/LemoNode/a9dc1a454fdc80ff2a738a9990935e9d&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Multiline chart&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;- 
&lt;a href=&#34;https://bl.ocks.org/larsenmtl/e3b8b7c2ca4787f77d78f58d41c3da91&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Multiline chart with mouseover&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;- 
&lt;a href=&#34;https://www.d3-graph-gallery.com/graph/barplot_basic.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Barplot&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;- 
&lt;a href=&#34;https://www.d3-graph-gallery.com/graph/barplot_button_data_hard.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Barplot with button to change input&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;- 
&lt;a href=&#34;http://bl.ocks.org/KatiRG/5f168b5c884b1f9c36a5&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Barplot with clickable legend&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;- 
&lt;a href=&#34;https://bl.ocks.org/bricedev/0d95074b6d83a77dc3ad&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Grouped barplot&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;- 
&lt;a href=&#34;https://www.d3-graph-gallery.com/graph/circular_barplot_label.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Circular barplot&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;- 
&lt;a href=&#34;https://bl.ocks.org/jrzief/70f1f8a5d066a286da3a1e699823470f&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Bar chart race&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;- 
&lt;a href=&#34;https://www.d3-graph-gallery.com/graph/streamgraph_template.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Streamplot&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;- 
&lt;a href=&#34;https://bl.ocks.org/mbostock/4060954&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Streamplot with transitions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;- 
&lt;a href=&#34;http://duspviz.mit.edu/d3-workshop/mapping-data-with-d3/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Map&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;- 
&lt;a href=&#34;https://bl.ocks.org/heybignick/3faf257bbbbc7743bb72310d03b86ee8&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Force-directed graph&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;- 
&lt;a href=&#34;http://rt.live&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;rt.live&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;referências&#34;&gt;Referências&lt;/h2&gt;
&lt;p&gt;[1] F. Crameri, G. E. Shephard, P. J. Heron, &lt;em&gt;The misuse of colour in science communication&lt;/em&gt;. 
&lt;a href=&#34;https://www.nature.com/articles/s41467-020-19160-7&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Nature Communications 11, 5444 (2020).&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2] Scott, A. 
&lt;a href=&#34;https://www.amazon.com.br/Interactive-Visualization-Scott-Andrew-Murray/dp/1449339735&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;Interactive Data Visualization for the Web&lt;/em&gt;&lt;/a&gt; (O&amp;rsquo;Reilly Media, 2013)&lt;/p&gt;
&lt;p&gt;[3] Wilke, C. O. 
&lt;a href=&#34;https://www.amazon.com/gp/product/1492031089&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;Fundamentals of Data Visualization&lt;/em&gt;&lt;/a&gt; (O&amp;rsquo;Reilly Media, 2019)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PEP8 - Melhores práticas de estilo em Python</title>
      <link>https://ansesu.github.io/post/python-pep8/</link>
      <pubDate>Mon, 07 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://ansesu.github.io/post/python-pep8/</guid>
      <description>&lt;p&gt;Nos últimos tempos, precisei resgatar os códigos de análises que realizei durante o mestrado. Percebi que eles estão um pouco confusos e difíceis de ler. Com intuito de resolver esse problema, decidi buscar entender quais são as melhores práticas de estilo quando programando em Python. Esse post é, então, uma &lt;em&gt;colinha&lt;/em&gt; pra que eu possa sempre estar checando caso esqueça de algo. Pretendo ir atualizando essa página frequentemente na medida em que eu avançar na minha pesquisa. Usei como referência o PEP 8 do site oficial 
&lt;a href=&#34;https://www.python.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;python.org&lt;/a&gt;. As PEPs, &lt;em&gt;Python Enhancement Proposals&lt;/em&gt;, são documentos criados para informar os usuários de Python acerca de padrões, novos atributos, seus processos ou seus ambientes 
&lt;a href=&#34;#pep1&#34;&gt;[1]&lt;/a&gt;. Especificamente, a PEP 8 indica os padrões de estilo para quem programa nessa linguagem, a fim de que o código possa ser de mais fácil leitura 
&lt;a href=&#34;#pep8&#34;&gt;[2]&lt;/a&gt;. Então, vamos lá!&lt;/p&gt;
&lt;p&gt;(O código aqui mostrado foi copiado da referência 
&lt;a href=&#34;#pep8&#34;&gt;[2]&lt;/a&gt;)&lt;/p&gt;
&lt;h2&gt;Lista de Conteúdos&lt;/h2&gt;
&lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#layout-do-código&#34;&gt;Layout do código&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#indentação&#34;&gt;Indentação&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#espaço-ou-tab&#34;&gt;Espaço ou tab?&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#tamanho-máximo-da-linha&#34;&gt;Tamanho máximo da linha&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#operadores-binários-e-quebra-de-linha&#34;&gt;Operadores binários e quebra de linha&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#linhas-brancas&#34;&gt;Linhas brancas&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#source-file-encoding&#34;&gt;Source File Encoding&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#imports&#34;&gt;Imports&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#referências&#34;&gt;Referências&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;h2 id=&#34;layout-do-código&#34;&gt;Layout do código&lt;/h2&gt;
&lt;h3 id=&#34;indentação&#34;&gt;Indentação&lt;/h3&gt;
&lt;p&gt;Padrão: 4 espaços por nível de indentação&lt;/p&gt;
&lt;!-- Continuation lines should align wrapped elements either vertically using Python&#39;s implicit line joining inside parentheses, brackets and braces, or using a hanging indent [7]. When using a hanging indent the following should be considered; there should be no arguments on the first line and further indentation should be used to clearly distinguish itself as a continuation line: --&gt;
&lt;p&gt;Algumas maneiras corretas de utilizar:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Alinhamento com o delimitador inicial &amp;quot;(&amp;quot;.
foo = long_function_name(var_one, var_two,
                         var_three, var_four)

# Adição de 4 espaços (um nível adicional de indentação) para distinguir a função de seus argumentos.
def long_function_name(
        var_one, var_two, var_three,
        var_four):
    print(var_one)

# A indentação flutuante deve sempre adicionar um nível. 
# No exemplo abaixo, não há um nível anterior, porém, ainda assim adicionamos um nível.
foo = long_function_name(
    var_one, var_two,
    var_three, var_four
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Porém, em algumas ocasiões, é necessário escolher qual das opções é mais adequada para situação:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Errado. Não é possível distinguir os argumentos e o conteúdo da função.
def long_function_name(
    var_one, var_two, var_three,
    var_four):
    print(var_one)
# Correto.
def long_function_name(var_one, var_two, 
                        var_three, var_four):
	print(var_one)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;indentação-estrutura-condicional-if&#34;&gt;Indentação: estrutura condicional if&lt;/h4&gt;
&lt;p&gt;Quando um condicional &lt;span class=&#34;markup-quote&#34;&gt;if&lt;/span&gt; é muito longo, pode ser que haja um problema ao quebrá-lo em múltiplas linhas:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;if (this_is_one_thing and
    that_is_another_thing):
    do_something()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Não conseguimos distinguir o condicional e seu conteúdo justamente porque a parte &lt;span class=&#34;markup-quote&#34;&gt;if (&lt;/span&gt; contém quatro caracteres. Duas possíveis opções são:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Adicione um comentário entre as linhas.
if (this_is_one_thing and
    that_is_another_thing):
    # Since both conditions are true, we can frobnicate.
    do_something()

# Adicione uma indentação na próxima linha do condicional.
if (this_is_one_thing
        and that_is_another_thing):
    do_something()
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;indentação-colcheteparênteseschaves&#34;&gt;Indentação: colchete/parênteses/chaves&lt;/h4&gt;
&lt;p&gt;Além disso, o colchete/parênteses/chaves que fecha uma construção em multi-linha pode se alinhar com o primeiro caractere (não-espaço) da última linha da lista&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;my_list = [
    1, 2, 3,
    4, 5, 6,
    ]
result = some_function_that_takes_arguments(
    &#39;a&#39;, &#39;b&#39;, &#39;c&#39;,
    &#39;d&#39;, &#39;e&#39;, &#39;f&#39;,
    )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ou alinhar com o primeiro caractere da linha que inicia a lista:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;my_list = [
    1, 2, 3,
    4, 5, 6,
]
result = some_function_that_takes_arguments(
    &#39;a&#39;, &#39;b&#39;, &#39;c&#39;,
    &#39;d&#39;, &#39;e&#39;, &#39;f&#39;,
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;espaço-ou-tab&#34;&gt;Espaço ou tab?&lt;/h3&gt;
&lt;p&gt;Padrão: espaços são preferíveis a tabs.&lt;/p&gt;
&lt;p&gt;No caso em que a indentação de algum código já está em tab, pode se usar tab para casar os padrões. Porém, começando um projeto do zero, é usar espaços (quatro)!&lt;/p&gt;
&lt;h3 id=&#34;tamanho-máximo-da-linha&#34;&gt;Tamanho máximo da linha&lt;/h3&gt;
&lt;p&gt;Padrão: limite de 79 caracteres por linha (no geral). Para docstrings e comentários, o tamanho máximo deve ser limitado a 72 caracteres.&lt;/p&gt;
&lt;p&gt;Achei meio estranho limitar o tamanho da linha em 79 caracteres, mas o PEP 8 menciona dois motivos pelos quais essa escolha pode ser interessante (além da padronização):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Esse tamanho permite abrir dois códigos lado a lado, o que ajuda em revisões, por exemplo;&lt;/li&gt;
&lt;li&gt;Certos editores tem um tamanho de linha máxima de 80 caracteres. Tamanhos maiores do que esse &amp;ldquo;estragariam&amp;rdquo; a formatação do código, tornando-o de difícil leitura. Assim, o limite de 79 caracteres é um limite seguro (por um caractere).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Porém, para uma equipe que prefere linhas mais longas e possui um código que é exclusivamente/primariamente mantido por ela, se chegarem a um consenso, não há problema em aumentar o tamanho da linha para até 99 caracteres.&lt;/p&gt;
&lt;p&gt;Para auxiliar na padronização, o 
&lt;a href=&#34;https://jupyter-contrib-nbextensions.readthedocs.io/en/latest/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Jupyter Noteboook Extensions&lt;/a&gt; conta com uma ferramenta chamada &lt;span class=&#34;markup-quote&#34;&gt;ruler&lt;/span&gt; para mostrar uma linha vertical no limite imposto pelo próprio usuário. Abaixo uma figura de um pedaço do meu código mostrando essa ferramenta.&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-exemplo-de-código-com-a-ferramenta-ruler-do-jupyter-notebook-extensions&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://ansesu.github.io/post/python-pep8/img/ruler_jupyter_hu25c5c2ff0017a65e26589dbedbef0d7b_72447_2000x2000_fit_lanczos_3.png&#34; data-caption=&#34;Exemplo de código com a ferramenta ruler do Jupyter Notebook Extensions.&#34;&gt;


  &lt;img data-src=&#34;https://ansesu.github.io/post/python-pep8/img/ruler_jupyter_hu25c5c2ff0017a65e26589dbedbef0d7b_72447_2000x2000_fit_lanczos_3.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;833&#34; height=&#34;580&#34;&gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Exemplo de código com a ferramenta ruler do Jupyter Notebook Extensions.
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;Para quebrar linhas, recomenda-se encapsular a expressão dentro de parênteses, chaves ou colchetes. Quando isso não é aplicável, é possível também usar a barra invertida para quebrar linhas, mas esse é o menos preferível. Por exemplo, quando se declara &lt;span class=&#34;markup-quote&#34;&gt;with&lt;/span&gt; ou &lt;span class=&#34;markup-quote&#34;&gt;assert&lt;/span&gt;, não é possível usar a continuação implícita:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;with open(&#39;/path/to/some/file/you/want/to/read&#39;) as file_1, \
     open(&#39;/path/to/some/file/being/written&#39;, &#39;w&#39;) as file_2:
    file_2.write(file_1.read())
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;operadores-binários-e-quebra-de-linha&#34;&gt;Operadores binários e quebra de linha&lt;/h3&gt;
&lt;p&gt;Padrão: escrever os operadores no início de uma nova linha.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;income = (gross_wages
          + taxable_interest
          + (dividends - qualified_dividends)
          - ira_deduction
          - student_loan_interest)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;É possível melhor entender a relação entre as variáveis descritas. No caso mostrado acima, percebe-se que existem quantidades que devem ser somadas, pois indicam um crédito, e outras subtraídas uma vez que indicam um débito. A posição do operador no início é conveniente, pois a operação sendo realizada é explícita, além do que todos os operadores ficam alinhados, o que melhora a legibilidade do código.&lt;/p&gt;
&lt;h3 id=&#34;linhas-brancas&#34;&gt;Linhas brancas&lt;/h3&gt;
&lt;p&gt;Padrões:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;O início das definições de funções e classes devem começar com duas linhas brancas;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Definições de métodos dentro de classes devem ser envoltos de uma linha branca;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Linhas brancas podem ser usadas para separar grupos de funções correlatas;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Linhas brancas podem ser usadas em funções para separar seções lógicas;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Python aceita o comando &lt;span class=&#34;markup-quote&#34;&gt;Ctrl+L&lt;/span&gt; para introduzir um espaço em branco, apesar de outras ferramentas usam esses caracteres como separadores de página.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;source-file-encoding&#34;&gt;Source File Encoding&lt;/h3&gt;
&lt;p&gt;Uma pequena e resumida explicação sobre codificação de caracteres:&lt;/p&gt;
&lt;p&gt;Cada caractere é armazenado em computadores como uma string de &lt;em&gt;bits&lt;/em&gt; &amp;ndash; zeros e uns &amp;ndash; ou um conjunto dessas strings. Cada sequência de 8 &lt;em&gt;bits&lt;/em&gt; compõe 1 &lt;em&gt;byte&lt;/em&gt;. Os sistemas de decodificação transformam a informação em &lt;em&gt;bits&lt;/em&gt; para linguagem humana escrita.&lt;/p&gt;
&lt;p&gt;O ASCII (&lt;em&gt;American Standard Code for Information Interchange&lt;/em&gt;) é um sistema de codificação para todos os caracteres presentes na lingua inglesa. Nele, cada caractere é representado por um único &lt;em&gt;byte&lt;/em&gt;. Dessa forma, apenas 128 bytes são necessários para representar todos os caracteres e símbolos contidos na língua inglesa.&lt;/p&gt;
&lt;p&gt;O padrão UTF-8 (&lt;em&gt;8-bit Unicode Transformation Format&lt;/em&gt;), por sua vez, engloba caracteres de outras línguas e até emojis. Esse feito não é possível no padrão ASCII, pois os caracteres têm um tamanho fixo de um &lt;em&gt;byte&lt;/em&gt;. Dessa forma, existe um limite de $2^{8} = 256$ possíveis caracteres únicos em ASCII.&lt;/p&gt;
&lt;p&gt;No UTF-8, qualquer 
&lt;a href=&#34;https://en.wikipedia.org/wiki/List_of_Unicode_characters&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;caractere &lt;em&gt;Unicode&lt;/em&gt;&lt;/a&gt; pode ser traduzido para uma sequência de números binários e vice-versa. É dessa forma que surge o nome &amp;ldquo;formato de transformação unicode&amp;rdquo;, isto é, &lt;em&gt;Unicode Transformation Format&lt;/em&gt;. Cada unidade de código é composto por 8 bits (1 &lt;em&gt;byte&lt;/em&gt;) e, assim, temos o &lt;em&gt;&lt;strong&gt;8-bit&lt;/strong&gt; Unicode Transformation Format&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Diferentemente do ASCII, até quatro unidades de código (4 &lt;em&gt;bytes&lt;/em&gt;) podem ser utilizadas para representar um caractere, isto é, sua forma decodificada. &lt;strong&gt;Até&lt;/strong&gt; quatro unidades porque a quantidade é dinâmica, &amp;ldquo;poupando&amp;rdquo; espaço quando possível. Por outro lado, a forma codificada (o que chamamos de 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Code_point&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;code point&lt;/em&gt;&lt;/a&gt;) é totalmente definida em termos do padrão de codificação &lt;em&gt;Unicode&lt;/em&gt; especificado. O &lt;em&gt;code point&lt;/em&gt; é um valor inteiro, especificado de acordo com uma representação hexadecimal. Assim, existem 1,114,112 &lt;em&gt;code points&lt;/em&gt; (de $0$ a $10FFFF$ ou $17\cdot16^{4}$) divididos em até 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Plane_%28Unicode%29&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;17 planos&lt;/a&gt;, que correspondem ao prefixo de $0$ a $10$ em notação hexadecimal.&lt;/p&gt;
&lt;p&gt;Por exemplo, o caractere &amp;ldquo;A&amp;rdquo; é representado pelo &lt;em&gt;code point&lt;/em&gt; &lt;strong&gt;U+0041&lt;/strong&gt; (U+número hexadecimal do &lt;em&gt;code point&lt;/em&gt;) e tem a representação binária &lt;strong&gt;01000001&lt;/strong&gt; (1 &lt;em&gt;byte&lt;/em&gt;). Enquanto isso, o caractere &amp;ldquo;あ&amp;rdquo; do alfabeto japonês &lt;em&gt;hiragana&lt;/em&gt; &amp;ndash; que também se lê &amp;ldquo;a&amp;rdquo; &amp;ndash; é representado pelo &lt;em&gt;code point&lt;/em&gt; &lt;strong&gt;U+3042&lt;/strong&gt; e tem representação binária de três &lt;em&gt;bytes&lt;/em&gt;: &lt;strong&gt;11100011&lt;/strong&gt;, &lt;strong&gt;10000001&lt;/strong&gt; e &lt;strong&gt;10000010&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Os primeiros 256 caracteres da biblioteca &lt;em&gt;Unicode&lt;/em&gt; são aqueles presentes no ASCII, estes representados apenas por um &lt;em&gt;byte&lt;/em&gt;. Portanto, a biblioteca ASCII é um sub-conjunto do UTF-8 e textos em ASCII têm compatibilidade com textos em UTF-8.&lt;/p&gt;
&lt;p&gt;Padrões:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;O código no &lt;em&gt;core&lt;/em&gt; da distribuição Python deve sempre usar UTF-8 (ou ASCII na versão Python 2);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Arquivos usando ASCII (em Python 2) ou UTF-8 (em Python 3) não devem ter uma declaração de &lt;em&gt;encoding&lt;/em&gt;;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Nas bibliotecas padrões, &lt;em&gt;encodings&lt;/em&gt; não-padrões devem ser usadas apenas com propósito de teste, ou quando um comentário/&lt;em&gt;docstring&lt;/em&gt; precisa mencionar um nome de autor que contém caracteres não-ASCII; caso contrário, preferencialmente inclui-se dados não-ASCII por meio dos escapes \x, \u, \U ou \N;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Para versões de Python acima da 3.0, os identificadores (nome dado a classes, funcões, variáveis etc) devem conter apenas caracteres ASCII e usar palavras em inglês sempre que possível (em vários casos, abreviações e termos técnicos são usados e não são em inglês). Além disso, strings e comentários também devem estar em ASCII. As exceções são as seguintes: (a) em caso de teste de &lt;em&gt;features&lt;/em&gt; não-ASCII; (b) nome de autores. Autores cujos nomes não são baseados no alfabeto latino (set de caracteres latin-1, ISO/IEC 8859-1) devem fornecer uma transliteração dos nomes em ASCII;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Projetos &lt;em&gt;open source&lt;/em&gt; com público global são encorajados a adotar políticas similares.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;imports&#34;&gt;Imports&lt;/h3&gt;
&lt;p&gt;Padrões&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Os imports de bibliotecas devem estar em linhas separadas:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Correto.
import os
import sys
# Errado.
import os, sys
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Porém, pode-se fazer:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from subprocess import Popen, PIPE
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Os imports devem ser colocados sempre no topo do arquivo, logo depois de qualquer comentário do módulo ou &lt;em&gt;docstrings&lt;/em&gt;, e antes de variáveis globais ou constantes do módulo.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Em geral, devem ser agrupados na seguinte ordem:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Imports da biblioteca padrão;&lt;/li&gt;
&lt;li&gt;Imports de programas de terceiros;&lt;/li&gt;
&lt;li&gt;Imports de aplicações locais/bibliotecas específicas.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Deve haver uma linha branca separando cada grupo.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Imports absolutos &amp;ndash; especificando o caminho inteiro até o pacote &amp;ndash; são recomendados, porque eles geralmente são mais legíveis e tendem a se comportar melhor (ou ao menos dar mensagens de erro melhores) se o sistema de importação estiver configurado incorretamente (como quando um diretório dente do pacote acaba no sys.path):&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import mypkg.sibling
from mypkg import sibling
from mypkg.sibling import example
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Porém, imports relativos explícitos &amp;ndash; especificando o caminho relativo da posição atual até o pacote &amp;ndash; são uma alternativa aceitável a imports absolutos, especialmente quando se lida com layouts complexos de pacotes quando o uso de imports absolutos seria desnecessariamente prolixo:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from . import sibling
from .sibling import example
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Código de bibliotecas padrões deve sempre evitar layouts complexos de pacotes e sempre usar imports absolutos.&lt;/p&gt;
&lt;p&gt;Imports relativos implícitos nunca devem ser utilizados e foram removidos do Python 3.&lt;/p&gt;
&lt;h2 id=&#34;referências&#34;&gt;Referências&lt;/h2&gt;
&lt;p&gt;&lt;a name=&#34;pep1&#34;&gt; [1] 
&lt;a href=&#34;https://www.python.org/dev/peps/pep-0001/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PEP 1 &amp;ndash; PEP Purpose and Guidelines.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name=&#34;pep8&#34;&gt; [2] 
&lt;a href=&#34;https://www.python.org/dev/peps/pep-0008/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PEP 8 &amp;ndash; Style Guide for Python Code.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://blog.hubspot.com/website/what-is-utf-8&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;What is UTF-8 Encoding? A Guide for Non-Programmers&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://stackoverflow.com/questions/27331819/whats-the-difference-between-a-character-a-code-point-a-glyph-and-a-grapheme&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;What&amp;rsquo;s the difference between a character, a code point, a glyph and a grapheme?&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Uma alternativa para o cálculo do número de reprodução em Maringá</title>
      <link>https://ansesu.github.io/post/rt-live-maringa/</link>
      <pubDate>Tue, 07 Jul 2020 00:00:00 +0000</pubDate>
      <guid>https://ansesu.github.io/post/rt-live-maringa/</guid>
      <description>&lt;p&gt;Gostaria de deixar claro que, de maneira alguma, posso ser considerado um epidemiologista. O intuito desse post é de alguma forma poder contribuir com estimativas mais precisas para o número de reprodução em Maringá, mas conclusões devem ser tomadas mediante a utilização de uma variedade parâmetros.&lt;/p&gt;
&lt;p&gt;O número de reprodução é o número esperado de infecções decorrentes de um indivíduo que se tornou infeccioso no tempo $t$. Do ponto de vista da saúde pública, é de interesse que esse número permaneça abaixo do limiar epidêmico ($R=1$), o que indica que a epidemia está desacelerando. O número de reprodução básico $R_0$ é a estimativa para essa quantidade no início da epidemia, quando a população inteira está suscetível à doença. Porém, ao passo que parcela da população ganha imunidade e medidas de intervenção são tomadas, o número de reprodução básico não tem mais validade e a atenção muda para o cálculo do que chamamos de número de reprodução que varia no tempo $R(t)$. Como exemplo, é possível citar os números de reprodução instantâneo e efetivo. Como se bem sabe, nenhum modelo é perfeito visto que sempre existem suposições e hipóteses necessárias para que a modelagem seja realizada. Além disso, existe uma limitação inerente da natureza do dado que, sendo mais ou menos detalhado, impacta na qualidade do modelo. A seguir, vou discorrer um pouco sobre a implementação que fizemos desses dois modelos para o caso de Maringá e sobre a limitação de dados públicos disponíveis nesse caso.&lt;/p&gt;
&lt;h2&gt;Lista de Conteúdos&lt;/h2&gt;
&lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#número-de-reprodução-efetivo&#34;&gt;Número de reprodução efetivo&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#número-de-reprodução-instantâneo&#34;&gt;Número de reprodução instantâneo&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#resultados&#34;&gt;Resultados&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#recursos-interessantes&#34;&gt;Recursos interessantes&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#referências&#34;&gt;Referências&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;h2 id=&#34;número-de-reprodução-efetivo&#34;&gt;Número de reprodução efetivo&lt;/h2&gt;
&lt;p&gt;Anteriormente, no &lt;em&gt;website&lt;/em&gt; 
&lt;a href=&#34;http://complex.pfi.uem.br/covid&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Observatório COVID-19 Maringá&lt;/a&gt;, calculamos o número de reprodução instantâneo $R_{inst}(t)$ utilizando o pacote EpiEstim do R 
&lt;a href=&#34;#EpiEstim&#34;&gt;[1]&lt;/a&gt;. Uma breve explicação sobre esse modelo se encontra no final desta postagem. Em poucas palavras, ele estima o número de reprodução instântaneo por meio do padrão de transmissibilidade do vírus nos últimos dias. Ao acompanhar a evolução da COVID-19 em Maringá, percebemos que as estimativas desse parâmetro poderiam estar atrasadas em alguns dias. Isso acontece devido à natureza dos dados disponibilizados pela Secretaria Municipal de Saúde de Maringá, uma vez que utilizamos dados dos casos confirmados diários de COVID-19. Disso, dois principais problemas decorrem:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Primeiro, consideramos que o número diário de casos confirmados de COVID-19 tem a mesma interpretação de número de infecções diárias por COVID-19. No entanto, sabe-se que existe um período de incubação do vírus, um atraso da notificação e, além disso, um atraso decorrente da espera pelo resultado do teste. A data de confirmação não é igual à data de infecção do indivíduo. Assim, nossas estimativas do número de reprodução instântaneo sempre estarão atrasadas em relação ao seu valor verdadeiro;&lt;/li&gt;
&lt;li&gt;O segundo problema é que, como o volume de testes varia, é certo que estamos subestimando o número de confirmados.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Esses dois problemas podem ser resolvidos utilizando o modelo do 
&lt;a href=&#34;#rt_instantaneo&#34;&gt;número de reprodução instantâneo&lt;/a&gt; aliado a técnicas de &lt;em&gt;nowcasting&lt;/em&gt; 
&lt;a href=&#34;#nowcast&#34;&gt;[2]&lt;/a&gt; e correções no número de confirmados pelo volume de testagem. Porém, para isso, seriam necessários dados de atraso para todos os confirmados e de volume de testagem diária, o que não temos. A alternativa que aqui apresento realiza essas correções de maneira unificada, isto é, por meio de um único processo que engloba todas essas considerações. Além disso, ela relaxa a necessidade de possuir a integridade dos dados de atraso de notificação. Com esse intuito, consideramos que o atraso pode ser aproximadamente constante no tempo e estimado por informações retiradas de outra base de dados. Recorremos ao método utilizado pelo &lt;em&gt;website&lt;/em&gt; 
&lt;a href=&#34;http://rt.live&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;rt.live&lt;/a&gt; para o cálculo do número de reprodução efetivo $R_{ef}(t)$. Diferentemente do número de reprodução instantâneo, estimativas do número de reprodução efetivo advêm de simulações da epidemia como um todo, e não utilizam apenas os dados dos últimos dias. Dessa forma, o modelo pode ser denominado &lt;strong&gt;generativo&lt;/strong&gt;, pois gera a curva de contágio desde o início da epidemia. Inicialmente, supomos que o número de reprodução $R_{ef}(t)$ caminha aleatoriamente, isto é,
$$
\log R_{ef}(t) \sim \mathcal{N}[R_{ef}(t-1), \sigma=0.1]\ ,
$$
em que $\sigma$ indica o quão rapidamente o número de reprodução pode variar diariamente. Além disso, supomos que existem uma parcela de indivíduos que iniciam a epidemia e estão distribuídos como
$$
\text{Primeiros infectados} \sim Exp(\lambda=50)\ .
$$
A partir disso, podemos simular a epidemia por meio da relação
$$
I(t) = R_{ef}(t)\sum_s I(t-s)w(s)\ ,
$$
sendo $I(t)$ o número de infectados no tempo $t$, $w(s)$ a distribuição de probabilidade do intervalo de tempo de geração e $s$ o número de dias anteriores. A distribuição de probabilidade $w(s)$ é a distribuição da diferença das datas de infecção entre casos primários e secundários. Utilizamos as estimativas de Nishiura et al. 
&lt;a href=&#34;#serial-covid&#34;&gt;[3]&lt;/a&gt; para gerar a distribuição $w(s)$ com média $\mu=4.7$ dias e desvio padrão $\sigma=2.9$ dias, como utilizados no 
&lt;a href=&#34;http://rt.live&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;rt.live&lt;/a&gt;. O primeiro erro do modelo utilizado anteriormente foi considerar que $I(t)$ é o número de infectados diários, mas, na verdade, utilizamos dados de confirmados diários. Temos estimativas para o tempo de incubação do vírus ($\approx$ 5 dias 
&lt;a href=&#34;#incubation&#34;&gt;[4]&lt;/a&gt;) e para o atraso do resultado do teste ($\approx$ 2 dias). Para incorporar o atraso da notificação, utilizamos informações do banco de dados 
&lt;a href=&#34;https://opendatasus.saude.gov.br/dataset/bd-srag-2020&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SRAG 2020&lt;/a&gt; disponibilizados pelo DATASUS. A Síndrome Respiratória Aguda Grave (SRAG) é um conjunto de sintomas (febre, tosse/dor de garganta, dispineia/saturação de oxigênio/desconforto respiratório) e tem notificação obrigatória no Sistema de Informação da Vigilância Epidemiológia da Gripe (SIVEP-Gripe). Esse sistema existe desde 2009 e foi criado com intuito de coletar informações sobre SRAG na epidemia de H1N1. O preenchimento é realizado através de uma ficha cadastral que inclui dados como data de primeiro sintomas e data de notificação. Recentemente, em 21/03/2020, o SARS-CoV-2 passou a integrar o painel de vírus testados para casos de SRAG. Utilizamos os dados de casos positivados de COVID-19 em Maringá nesse banco de dados para estimar o atraso entre os primeiros sintomas e a notificação do caso. Consideramos, aqui, que o atraso de notificação é constante no tempo (uma hipótese importante). Em outras palavras, consideramos que, desde o começo da epidemia até hoje, os casos têm o mesmo atraso de notificação. Além disso, o dado que possuímos é parcial, pois nem todos os casos de COVID-19 evoluem para SRAG, mas consideramos que é uma aproximação razoável. Uma melhor solução seria utilizar a base de dados integral para todos os casos confirmados na cidade se estes fossem disponibilizados pela Secretaria de Saúde, porém, este não é o caso. A partir do banco de dados SRAG 2020, do tempo de incubação do vírus e do atraso da testagem, estimamos uma distribuição de probabilidade que denominaremos $h(s)$ sendo $s$ o número de dias anteriores à confirmação do caso. A partir dessa distribuição, realizamos uma convolução para estimar a data de infecção dos casos, ou seja,
$$
I(t) = I_{c}(t)*h(s)\ ,
$$
em que $I_{c}(t)$ o número de casos confirmados no tempo $t$.&lt;/p&gt;
&lt;p&gt;O segundo problema (de testagem) pode ser contornado utilizando uma distribuição binomial negativa com um parâmetro de exposição para cada dia. A distribuição binomial negativa é mais flexível que uma distribuição de Poisson, pois permite que a variabilidade seja diferente do parâmetro de localização do modelo. O parâmetro de exposição, por sua vez, leva em consideração as diferentes taxas de testagem diárias. Em outras palavras, ajustamos o número de casos pela quantidade de &amp;ldquo;oportunidade&amp;rdquo; que um evento possui. Para entender melhor, considere que a taxa possa ser escrita como
$$
\text{taxa} = \dfrac{\text{contagem}}{\text{exposição}}\ .
$$
Para ser mais didático, considere que duas pessoas frequentam determinado hospital. Uma delas frequenta 3 vezes por semana e a outra 3 vezes por ano. É evidente que as taxas são diferentes, pois estão em escalas de tempo diferentes, apesar de a contagem de idas ao hospital ser a mesma. Dessa maneira, precisamos considerar a contagem levando em consideração a exposição, para isso, reescrevemos a equação anterior como
$$
\text{contagem} = \text{taxa}\cdot\text{exposição}\ .
$$
No caso da COVID-19, a exposição é a quantidade de testes diários. Se há mais testes, é claro que possivelmente o número de casos confirmados deve ser maior. Incorporando essa informação ao modelo temos que o número de infectados pode ser escrito como
$$
I(t) \sim NegBin(\mu, \alpha)\ ,
$$
$$
\mu = I(t) \cdot \text{exposição}\ ,
$$
$$
\alpha \sim Gamma(\mu=6,\sigma=1)\ ,
$$
de acordo com 
&lt;a href=&#34;https://docs.pymc.io/api/distributions/discrete.html#pymc3.distributions.discrete.NegativeBinomial&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;esta definição&lt;/a&gt; da distribuição binomial negativa. O número de testes diários foi estimado utilizando dados dos boletins diários de acordo com a relação:
$$
\text{testes} = \text{número de confirmados diário} + \text{número de encerrados diário}\ .
$$
Completamos os dados de testagem anteriores à data de 31/03/2020 supondo que havia uma frequência uniforme de trinta testes diários, uma vez que esses dados não estavam disponíveis à época.&lt;/p&gt;
&lt;p&gt;Como já mencionamos, este modelo difere daquele para o número de reprodução instantâneo, pois gera a curva inteira de infecção de acordo com os dados e, assim, tem como condição que a curva seja quasi-contínua. Estimativas com novos dados diários mudam as estimativas de datas anteriores e, ao atualizar todas as estimativas com novas informações, considero que é um modelo que pode ser considerado mais honesto. Além disso, incorporamos as soluções para os dois problemas anteriormente constatados. Dessa forma, o número de reprodução estimado deve representar a situação atual de infectividade da COVID-19 de maneira mais próxima da realidade. Amostramos esse modelo utilizando o pacote 
&lt;a href=&#34;https://docs.pymc.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PyMC3&lt;/a&gt; do Python.&lt;/p&gt;
&lt;h2 id=&#34;número-de-reprodução-instantâneo&#34;&gt;Número de reprodução instantâneo&lt;/h2&gt;
&lt;p&gt;Como mencionado anteriormente, o número de reprodução básico $R_0$ do modelo SIR é uma propriedade da fase inicial da epidemia e indica o número de casos secundários médio que decorrem de um indivíduo infectado. Nesse período inicial, existe um regime exponencial de crescimento para o número de infectados $I(t)$. No entanto, em estágios mais avançados da epidemia, essa suposição não é mais verdadeira, sendo necessária a adoção de modelos alternativos. Uma opção é a escolha de abordagens que levam em conta o perfil de infectividade dos contaminados, também conhecidos como modelos &lt;em&gt;time-since-infection&lt;/em&gt; 
&lt;a href=&#34;#time-since-infection&#34;&gt;[5]&lt;/a&gt;. A partir deles, é possível calcular o número de reprodução instantaneamente no tempo $t$, que apresenta a mesma interpretação do número de reprodução básico, porém tem validade para qualquer momento da epidemia. Para isso, podemos modelar a transmissão de COVID-19 como um processo de Poisson por meio de uma abordagem Bayesiana. O número de reprodução instantâneo pode ser descrito como
$$
R_{inst}(t) = \dfrac{I(t)}{\sum_{s=1}^{\tau} I(t-s)w(s)}\ ,
$$
em que $w(s)$ é o perfil de infectividade, ou distribuição do tempo de geração, e $\tau$ é a janela temporal considerada para estimar o $R_{inst}(t)$, considerando que o número de reprodução instantâneo permanece constante no intervalo $[t-\tau+1, t]$. O perfil de infectividade $w(s)$ é uma distribuição de probabilidade que depende do tempo desde a infecção por COVID-19. Dessa forma, maiores valores de $w(s)$ indicam que os infectados $I(t-s)$ estão mais suscetíveis a transmitir a doença nesse período. A distribuição $w(s)$ depende apenas em fatores biológicos individuais como características do vírus e severidade dos sintomas 
&lt;a href=&#34;#EpiEstim&#34;&gt;[1]&lt;/a&gt;. Dessa maneira, o número de reprodução instantâneo $R_{inst}(t)$ como calculado na equação acima equivale ao número médio de casos gerados pelos infectados na janela de $\tau$ dias anteriores. A verossimilhança para $I(t)$ pode ser escrita como uma distribuição de Poisson, isto é,
$$
\mathcal{L}[I(t)| I(t-\tau+1),\dots,I(t-1), w, R_{inst}(t)] = \dfrac{[R_{inst}(t)\Lambda(t)]^{I(t)}e^{R_{inst}(t)\Lambda(t)}}{I(t)!}\ ,
$$
em que
$$
\Lambda(t)=\sum_{s=1}^{\tau}I(t-s)w(s)\ .
$$
Dessa forma, supondo independência estatística entre os períodos, a verossimilhança dentro da janela $\tau$ pode ser escrita como
$$
\mathcal{L}[I(t-\tau+1),\dots,I(t)| w, R_{inst}(t)] = \prod_{s=t-\tau+1}^{t} \dfrac{[R_{inst}(t)\Lambda(s)]^{I(s)}e^{-R_{inst}(t)\Lambda(s)}}{I(s)}\ .
$$
Usando o teorema de Bayes, podemos calcular a distribuição a posteriori para estimar $R_{inst}(t)$, isto é,
$$
P[R_{inst}(t),I(t-\tau+1),\dots,I(t)| w ] \propto \mathcal{L}[I(t-\tau+1),\dots,I(t)| R_{inst}(t), w ] P[R_{inst}(t)]\ .
$$
Seguindo o procedimento proposto pelos sites 
&lt;a href=&#34;https://epiforecasts.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;epiforecasts.io&lt;/a&gt; e 
&lt;a href=&#34;https://covid19br.github.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;covid19br&lt;/a&gt;, consideramos que o perfil de infectividade é uma distribuição Gamma com média de 4.8 dias e desvio padrão de 2.3 dias, valores estimados em 
&lt;a href=&#34;#serial-covid&#34;&gt;[3]&lt;/a&gt; e utilizados por esses dois sites. Além disso, atribuímos incerteza ao perfil de infectividade amostrando a média e o desvio padrão de distribuições normais truncadas centradas nos valores descritos anteriormente para um total de 500 repetições. Consideramos que $R_{inst}(t)$ apresenta uma distribuição Gamma como priori, com média 2.6 e desvio padrão 2, o que leva em consideração estimativas do número de reprodução básico em Wuhan no começo da epidemia 
&lt;a href=&#34;#r0-wuhan&#34;&gt;[6]&lt;/a&gt;. Por fim, para a janela temporal $\tau$, adotamos o tempo $\tau=7$ dias uma vez que a série temporal de casos por COVID-19 aparenta uma periodicidade semanal. Aplicamos esse modelo utilizando o pacote 
&lt;a href=&#34;https://github.com/mrc-ide/EpiEstim&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;EpiEstim&lt;/a&gt; do R.&lt;/p&gt;
&lt;p&gt;Só lembrando: nesse modelo, consideramos que o número de infectados diário apresenta a mesma interpretação do número de confirmados diário. Sabemos, porém, que existe um atraso na confirmação dos casos. Desde o dia em que a pessoa é infectada, leva-se um tempo para o vírus incubar (cerca de cinco dias) e os sintomas se manifestarem. Além disso, também pode existir um atraso de notificação e de espera pelos resultados dos testes. Esses problemas seriam resolvidos se tivéssemos os dados referentes ao atraso de notificação e de data do começo dos sintomas para cada caso confirmado, a fim de realizar medidas de nowcasting 
&lt;a href=&#34;#nowcast&#34;&gt;[2]&lt;/a&gt;. Além disso, o modelo não leva em consideração o volume de testagem variável (isto é, que o número de testes varia diariamente), o que pode causar uma subestimação do número de reprodução instantâneo. Ainda assim, acredito que as estimativas do número de reprodução instantâneo podem transmitir informações importantes sobre o avanço da epidemia (mesmo que com atraso). Diferentemente do número de reprodução efetivo, as estimativas são mais sensíveis às variações mais recentes dos números de casos confirmados diários uma vez que não existe a condição de que a curva seja quasi-contínua.&lt;/p&gt;
&lt;h2 id=&#34;resultados&#34;&gt;Resultados&lt;/h2&gt;
&lt;p&gt;As figuras abaixo mostram, respectivamente, estimativas para o número de reprodução efetivo $R_{ef}(t)$ e instantâneo $R_{inst}(t)$ seguindo os procedimentos aqui descritos.&lt;/p&gt;
&lt;!-- One of the constraints of the model is that this curve be connected and smooth. So, if new data suggests that Rt should be higher, it will pull up previous values so that the newest point is connected. Imagine a rope lying on the ground. If you pick up the end of that rope, the rope needs to slope up to your hand. The same thing is roughly happening with the model. If all of a sudden a testing center releases far more tests than were expected, the Rt curve increases which drags up previous values of Rt. Since case data is staggered in its arrival, a bunch of new cases will sometimes rewrite its view of history given the new data. This is the most honest representation of the situation although it can feel disorienting if you don’t understand why it’s happening. --&gt;
&lt;!-- In the simplest terms, it searches for the most likely curve of Rt that produced the new cases per day that we observe. It does this through some neat (and powerful!) math that is beyond the scope of this FAQ. In more complex terms: we assume a seed number of people and a curve of Rt over the history of the pandemic, we then distribute those cases into the future using a known delay distribution between infection and positive report. We then scale and add noise based on known testing volumes via a negative binomial with an exposure parameter for a given day to recover an observed series. We plan on publishing our code soon, so if you’re so inclined you’ll be able to run it, too. --&gt;
&lt;!-- In general, hospitalizations and deaths are more reliable than tests to see the true Rt curve. However, they are also both time-shifted fairly dramatically from the time of infection. As of this time we have not included them in our model, but we are considering ways to reliably and accurately include them to ensure the model is as accurate as possible. --&gt;
&lt;div
 style=&#34;padding-bottom:73%; position:relative; display:block; width: 100%&#34;&gt;
 &lt;iframe
  width=&#34;100%&#34; height=&#34;100%&#34;
  src=&#34;html/rt_efetivo.html&#34;
  frameborder=&#34;0&#34; scrolling=&#34;no&#34;
  style=&#34;position:absolute; top:0; left: 0&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;p style=&#34;text-align: center&#34; &gt;Figura: evolução temporal do $R_{ef}(t)$ em Maringá.&lt;p/&gt;
&lt;a name=&#34;rt_instantaneo&#34;&gt;
&lt;div
 style=&#34;padding-bottom:73%; position:relative; display:block; width: 100%&#34;&gt;
 &lt;iframe
  width=&#34;100%&#34; height=&#34;100%&#34;
  src=&#34;html/rt_instantaneo.html&#34;
  frameborder=&#34;0&#34; scrolling=&#34;no&#34;
  style=&#34;position:absolute; top:0; left: 0&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;p style=&#34;text-align: center&#34; &gt;Figura: evolução temporal do $R_{inst}(t)$ em Maringá.&lt;p/&gt;,
&lt;p&gt;A figura abaixo mostra a evolução temporal das variáveis presentes no modelo generativo: i) o número de confirmados (em cinza); ii) o número de confirmados esperado (em verde); iii) o número de confirmados esperado supondo testagem uniforme (em laranja); iv) o número de infectados esperado (em roxo).&lt;/p&gt;
&lt;div
 style=&#34;padding-bottom:73%; position:relative; display:block; width: 100%&#34;&gt;
 &lt;iframe
  width=&#34;100%&#34; height=&#34;100%&#34;
  src=&#34;html/modelo_generativo.html&#34;
  frameborder=&#34;0&#34; scrolling=&#34;no&#34;
  style=&#34;position:absolute; top:0; left: 0&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;p style=&#34;text-align: center&#34; &gt;Figura: evolução temporal das variáveis presentes no modelo generativo em Maringá.&lt;p/&gt;
&lt;p&gt;O código para reprodução dessa análise está disponível em 
&lt;a href=&#34;https://github.com/ansesu/rtlive_maringa.git&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ansesu/rt_livemaringa&lt;/a&gt;. O código-base e maiores detalhes sobre o modelo podem ser encontrados no repositório original 
&lt;a href=&#34;https://github.com/rtcovidlive/covid-model/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;rtcovidlive/covid-model&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;recursos-interessantes&#34;&gt;Recursos interessantes&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://youtu.be/ezmWtCFceco&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hospitalizações por SRAG como proxy para casos graves de Covid-19 no Brasil&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;http://rt.live&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;rt.live&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://epiforecasts.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;epiforecasts&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://covid19br.github.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Observatório COVID-19 BR&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;referências&#34;&gt;Referências&lt;/h2&gt;
&lt;p&gt;&lt;a name=&#34;EpiEstim&#34;&gt; [1] A. Cori, N. M. Ferguson, C. Fraser,  S. Cauchemez, &lt;em&gt;A New Framework and Software to Estimate Time-Varying Reproduction Numbers During Epidemics&lt;/em&gt;. 
&lt;a href=&#34;https://doi.org/10.1093/aje/kwt133&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;American Journal of Epidemiology 178, 1505&amp;ndash;1512 (2013).&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name=&#34;nowcast&#34;&gt; [2] L. S. Bastos, T. Economou, M. F. C. Gomes, D. A. M. Villela, F. C. Coelho, O. G. Cruz, O. S.
T. Bailey, C. T. Codeço, &lt;em&gt;A modelling approach for correcting reporting delays in disease surveillance data&lt;/em&gt;. 
&lt;a href=&#34;https://doi.org/10.1002/sim.8303&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Statistics in Medicine 38, 4363-4377 (2019)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name=&#34;serial-covid&#34;&gt; [3] H. Nishiura, N.M. Linton, A.R. Akhmetzhanov, &lt;em&gt;Serial interval of novel coronavirus (COVID-19) infections&lt;/em&gt;. 
&lt;a href=&#34;https://doi.org/10.1016/j.ijid.2020.02.060&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;International Journal of Infectious Diseases 93, 284-286 (2020).&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name=&#34;incubation&#34;&gt; [4] S. A. Lauer, K. H. Grantz, Q. Bi, F. K. Jones, Q. Zheng, H. R. Meredith, A. S. Azman, N. G. Reich, J. Lessler, &lt;em&gt;The incubation period of coronavirus disease 2019 (COVID-19) from publicly reported confirmed cases: Estimation and application&lt;/em&gt;. 
&lt;a href=&#34;https://doi.org/10.7326/M20-0504&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Annals of Internal Medicine 172, 577-582 (2020).&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name=&#34;time-since-infection&#34;&gt; [5] C. Fraser, &lt;em&gt;Estimating Individual and Household Reproduction Numbers in an Emerging Epidemic&lt;/em&gt;. 
&lt;a href=&#34;https://doi.org/10.1371/journal.pone.0000758&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PLOS ONE 2(8), e758 (2007).&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name=&#34;r0-wuhan&#34;&gt; [6] S. Abbott, J. Hellewell, J. Munday, S. Funk, &lt;em&gt;The transmissibility of novel Coronavirus in the early stages of the 2019-20 outbreak in Wuhan: Exploring initial point-source exposure sizes and durations using scenario analysis&lt;/em&gt;. 
&lt;a href=&#34;https://doi.org/10.1186/1741-7015-7-30&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Wellcome Open Research 5, 17 (2020).&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
