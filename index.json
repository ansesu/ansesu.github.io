[{"authors":["assunahara"],"categories":null,"content":"Doutorando em Física no ComplexLab, Universidade Estadual de Maringá\n","date":1629072000,"expirydate":-62135596800,"kind":"term","lang":"pt","lastmod":1629072000,"objectID":"d10735df0444664a274d98fd2bf2d098","permalink":"https://ansesu.github.io/author/andre-s.-sunahara/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/andre-s.-sunahara/","section":"authors","summary":"Doutorando em Física no ComplexLab, Universidade Estadual de Maringá","tags":null,"title":"Andre S. Sunahara","type":"authors"},{"authors":null,"categories":null,"content":"","date":1633046400,"expirydate":-62135596800,"kind":"page","lang":"pt","lastmod":1633046400,"objectID":"b13d40e4e16793b46c94904f35f7f515","permalink":"https://ansesu.github.io/news/fapesp-2021/","publishdate":"2021-10-01T00:00:00Z","relpermalink":"/news/fapesp-2021/","section":"news","summary":"Ao analisar a produção científica ao longo da carreira de mais de 6 mil pesquisadores brasileiros de 14 disciplinas, a equipe do físico Haroldo Ribeiro, da Universidade Estadual de Maringá, no Paraná, identificou padrões distintos de comportamento em relação à publicação de artigos.","tags":["Science of science","Fapesp"],"title":"Engrenagens do conhecimento","type":"news"},{"authors":["Andre S. Sunahara","Matjaz Perc","Haroldo V. Ribeiro"],"categories":null,"content":"","date":1629072000,"expirydate":-62135596800,"kind":"page","lang":"pt","lastmod":1629072000,"objectID":"f7a6212d95b8d4416e6de58fe6cdec6f","permalink":"https://ansesu.github.io/publication/2021/association-between-productivity-and-journal-impact-across-disciplines-and-career-age/","publishdate":"2021-08-16T00:00:00Z","relpermalink":"/publication/2021/association-between-productivity-and-journal-impact-across-disciplines-and-career-age/","section":"publication","summary":"The association between productivity and impact of scientific production is a long-standing debate in science that remains controversial and poorly understood. Here we present a large-scale analysis of the association between yearly publication numbers and average journal-impact metrics for the Brazilian scientific elite. We find this association to be discipline specific, career age dependent, and similar among researchers with outlier and nonoutlier performance. Outlier researchers either outperform in productivity or journal prestige, but they rarely do so in both categories. Nonoutliers also follow this trend and display negative correlations between productivity and journal prestige but with discipline-dependent intensity. Our research indicates that academics are averse to simultaneous changes in their productivity and journal-prestige levels over consecutive career years. We also find that career patterns concerning productivity and journal prestige are discipline-specific, having in common a raise of productivity with career age for most disciplines and a higher chance of outperforming in journal impact during early career stages.","tags":["Science of science","Productivity","Journal impact"],"title":"Association between productivity and journal impact across disciplines and career age","type":"publication"},{"authors":null,"categories":null,"content":"","date":1625702400,"expirydate":-62135596800,"kind":"page","lang":"pt","lastmod":1625702400,"objectID":"8ba919c97644e470d04402ba91cfe315","permalink":"https://ansesu.github.io/news/conexao-covid/","publishdate":"2021-07-08T00:00:00Z","relpermalink":"/news/conexao-covid/","section":"news","summary":"Três físicos da UEM fundaram o Observatório COVID-19 Maringá, um site que surgiu da necessidade de registrar e analisar dados sobre a pandemia da Covid-19 na cidade.","tags":["COVID-19","Maringá"],"title":"A pandemia em dados: a Covid-19 decifrada para a sociedade","type":"news"},{"authors":["Andre"],"categories":[],"content":" De acordo com Crameri et al., \u0026ldquo;a representação precisa dos dados é essencial na comunicação científica\u0026rdquo; [1]. De fato, a escolha do tipo mais adequado de visualização de acordo com as características dos dados é imprescindível para comunicar os resultados de uma pesquisa científica. Por exemplo, o gráfico abaixo mostra a evolução temporal do número de reprodução efetivo $R(t)$ referente ao espalhamento da COVID-19 em Maringá. Ao representar valores acima de um, que indicam o aceleramento da propagação do vírus, em vermelho, e valores abaixo de um, que indicam o desaceleramento da propagação, em verde, podemos comunicar visualmente o ritmo de transmissão do vírus.\nFigura 1: gráfico de linha com intervalo de confiança e cores diferentes definidas por um limite. Valores acima do limite são coloridos de vermelho, enquanto valores abaixo desse mesmo limite são coloridos de verde. Visualização inspirada no site rt.live. O tamanho dos elementos também faz diferença quando representamos dados. A figura abaixo mostra o valor das minhas sequências ouvindo as mesmas faixas de determinado artista ou faixas únicas durante o ano de 2022. O tamanho dos marcadores varia com o tamanho da sequência, comunicando visualmente o tamanho da sequência.\nArtista Faixa\nFigura 2: scatter plot com tamanho do marker variável de acordo com valor da variável (com botão para troca de categoria). Como mencionado anteriormente, a escolha do tipo de figura de acordo com as características dos dados é essencial. A figura abaixo mostra o volume de faixas dos dez artistas mais ouvidos por mim durante 2022. Nesse contexto, faz sentido utilizar um gráfico de fluxo (stream chart) uma vez que, pela sua utilização, é possível transmitir a ideia de volume.\nFigura 3: stream chart plot. Neste post, apresento algumas figuras confeccionadas por meio do pacote d3.js e os respectivos tutoriais, além de alguns recursos que podem auxiliar no aprendizado de visualização de dados em geral. O código fonte para os gráficos podem ser acessados nesta página.\nGráfico de linha Total COVID\nFigura 4: figura com vários paineis (com botão para troca de categoria). Cada painel contém um gráfico de linha preenchido. Gráfico de barra Reload\nFigura 5: gráfico de corrida de barras. Média móvel Figura 6: gráfico de barras com média móvel e linha do tempo adjacente (com botão para desativação da média móvel). Mapa Casos Mortes\nFigura 7: mapa com escala de cor dependente da amplitude da variável (com botão para troca de categoria). Rede Figura 8: force-directed graph. Recursos - colorbrewer2\n- d3-time-format\n- SVG Attribute reference\n- D3 6.0 migration guide\n- How to Resize an SVG When the Window is Resized in d3.js\n- Scatterplot with tooltips\n- Multiline chart\n- Multiline chart with mouseover\n- Barplot\n- Barplot with button to change input\n- Barplot with clickable legend\n- Grouped barplot\n- Circular barplot\n- Bar chart race\n- Streamplot\n- Streamplot with transitions\n- Map\n- Force-directed graph\n- rt.live\nReferências [1] F. Crameri, G. E. Shephard, P. J. Heron, The misuse of colour in science communication. Nature Communications 11, 5444 (2020).\n[2] Scott, A. Interactive Data Visualization for the Web (O\u0026rsquo;Reilly Media, 2013)\n[3] Wilke, C. O. Fundamentals of Data Visualization (O\u0026rsquo;Reilly Media, 2019)\n","date":1622851200,"expirydate":-62135596800,"kind":"page","lang":"pt","lastmod":1622851200,"objectID":"6cbcb5cc038e6e3a6ae8bcb18eda053b","permalink":"https://ansesu.github.io/post/d3-visualizations/","publishdate":"2021-06-05T00:00:00Z","relpermalink":"/post/d3-visualizations/","section":"post","summary":"De acordo com Crameri et al., \u0026ldquo;a representação precisa dos dados é essencial na comunicação científica\u0026rdquo; [1]. De fato, a escolha do tipo mais adequado de visualização de acordo com as características dos dados é imprescindível para comunicar os resultados de uma pesquisa científica.","tags":["Visualização","d3.js"],"title":"Visualização de dados com d3.js","type":"post"},{"authors":["Andre"],"categories":[],"content":"Nos últimos tempos, precisei resgatar os códigos de análises que realizei durante o mestrado. Percebi que eles estão um pouco confusos e difíceis de ler. Com intuito de resolver esse problema, decidi buscar entender quais são as melhores práticas de estilo quando programando em Python. Esse post é, então, uma colinha pra que eu possa sempre estar checando caso esqueça de algo. Pretendo ir atualizando essa página frequentemente na medida em que eu avançar na minha pesquisa. Usei como referência o PEP 8 do site oficial python.org. As PEPs, Python Enhancement Proposals, são documentos criados para informar os usuários de Python acerca de padrões, novos atributos, seus processos ou seus ambientes [1]. Especificamente, a PEP 8 indica os padrões de estilo para quem programa nessa linguagem, a fim de que o código possa ser de mais fácil leitura [2]. Então, vamos lá!\n(O código aqui mostrado foi copiado da referência [2])\nLista de Conteúdos Layout do código Indentação Espaço ou tab? Tamanho máximo da linha Operadores binários e quebra de linha Linhas brancas Source File Encoding Imports Referências Layout do código Indentação Padrão: 4 espaços por nível de indentação\nAlgumas maneiras corretas de utilizar:\n# Alinhamento com o delimitador inicial \u0026quot;(\u0026quot;. foo = long_function_name(var_one, var_two, var_three, var_four) # Adição de 4 espaços (um nível adicional de indentação) para distinguir a função de seus argumentos. def long_function_name( var_one, var_two, var_three, var_four): print(var_one) # A indentação flutuante deve sempre adicionar um nível. # No exemplo abaixo, não há um nível anterior, porém, ainda assim adicionamos um nível. foo = long_function_name( var_one, var_two, var_three, var_four ) Porém, em algumas ocasiões, é necessário escolher qual das opções é mais adequada para situação:\n# Errado. Não é possível distinguir os argumentos e o conteúdo da função. def long_function_name( var_one, var_two, var_three, var_four): print(var_one) # Correto. def long_function_name(var_one, var_two, var_three, var_four): print(var_one) Indentação: estrutura condicional if Quando um condicional if é muito longo, pode ser que haja um problema ao quebrá-lo em múltiplas linhas:\nif (this_is_one_thing and that_is_another_thing): do_something() Não conseguimos distinguir o condicional e seu conteúdo justamente porque a parte if ( contém quatro caracteres. Duas possíveis opções são:\n# Adicione um comentário entre as linhas. if (this_is_one_thing and that_is_another_thing): # Since both conditions are true, we can frobnicate. do_something() # Adicione uma indentação na próxima linha do condicional. if (this_is_one_thing and that_is_another_thing): do_something() Indentação: colchete/parênteses/chaves Além disso, o colchete/parênteses/chaves que fecha uma construção em multi-linha pode se alinhar com o primeiro caractere (não-espaço) da última linha da lista\nmy_list = [ 1, 2, 3, 4, 5, 6, ] result = some_function_that_takes_arguments( 'a', 'b', 'c', 'd', 'e', 'f', ) ou alinhar com o primeiro caractere da linha que inicia a lista:\nmy_list = [ 1, 2, 3, 4, 5, 6, ] result = some_function_that_takes_arguments( 'a', 'b', 'c', 'd', 'e', 'f', ) Espaço ou tab? Padrão: espaços são preferíveis a tabs.\nNo caso em que a indentação de algum código já está em tab, pode se usar tab para casar os padrões. Porém, começando um projeto do zero, é usar espaços (quatro)!\nTamanho máximo da linha Padrão: limite de 79 caracteres por linha (no geral). Para docstrings e comentários, o tamanho máximo deve ser limitado a 72 caracteres.\nAchei meio estranho limitar o tamanho da linha em 79 caracteres, mas o PEP 8 menciona dois motivos pelos quais essa escolha pode ser interessante (além da padronização):\nEsse tamanho permite abrir dois códigos lado a lado, o que ajuda em revisões, por exemplo; Certos editores tem um tamanho de linha máxima de 80 caracteres. Tamanhos maiores do que esse \u0026ldquo;estragariam\u0026rdquo; a formatação do código, tornando-o de difícil leitura. Assim, o limite de 79 caracteres é um limite seguro (por um caractere). Porém, para uma equipe que prefere linhas mais longas e possui um código que é exclusivamente/primariamente mantido por ela, se chegarem a um consenso, não há problema em aumentar o tamanho da linha para até 99 caracteres.\nPara auxiliar na padronização, o Jupyter Noteboook Extensions conta com uma ferramenta chamada ruler para mostrar uma linha vertical no limite imposto pelo próprio usuário. Abaixo uma figura de um pedaço do meu código mostrando essa ferramenta.\nExemplo de código com a ferramenta ruler do Jupyter Notebook Extensions. Para quebrar linhas, recomenda-se encapsular a expressão dentro de parênteses, chaves ou colchetes. Quando isso não é aplicável, é possível também usar a barra invertida para quebrar linhas, mas esse é o menos preferível. Por exemplo, quando se declara with ou assert, não é possível usar a continuação implícita:\nwith open('/path/to/some/file/you/want/to/read') as file_1, \\ open('/path/to/some/file/being/written', 'w') as file_2: file_2.write(file_1.read()) Operadores binários e quebra de linha Padrão: escrever os operadores no início de uma nova linha.\nincome = (gross_wages + taxable_interest + (dividends - qualified_dividends) - ira_deduction - student_loan_interest) É possível melhor entender a relação entre as variáveis descritas. No caso mostrado acima, percebe-se que existem quantidades que devem ser somadas, pois indicam um crédito, e outras subtraídas uma vez que indicam um débito. A posição do operador no início é conveniente, pois a operação sendo realizada é explícita, além do que todos os operadores ficam alinhados, o que melhora a legibilidade do código.\nLinhas brancas Padrões:\nO início das definições de funções e classes devem começar com duas linhas brancas;\nDefinições de métodos dentro de classes devem ser envoltos de uma linha branca;\nLinhas brancas podem ser usadas para separar grupos de funções correlatas;\nLinhas brancas podem ser usadas em funções para separar seções lógicas;\nPython aceita o comando Ctrl+L para introduzir um espaço em branco, apesar de outras ferramentas usam esses caracteres como separadores de página.\nSource File Encoding Uma pequena e resumida explicação sobre codificação de caracteres:\nCada caractere é armazenado em computadores como uma string de bits \u0026ndash; zeros e uns \u0026ndash; ou um conjunto dessas strings. Cada sequência de 8 bits compõe 1 byte. Os sistemas de decodificação transformam a informação em bits para linguagem humana escrita.\nO ASCII (American Standard Code for Information Interchange) é um sistema de codificação para todos os caracteres presentes na lingua inglesa. Nele, cada caractere é representado por um único byte. Dessa forma, apenas 128 bytes são necessários para representar todos os caracteres e símbolos contidos na língua inglesa.\nO padrão UTF-8 (8-bit Unicode Transformation Format), por sua vez, engloba caracteres de outras línguas e até emojis. Esse feito não é possível no padrão ASCII, pois os caracteres têm um tamanho fixo de um byte. Dessa forma, existe um limite de $2^{8} = 256$ possíveis caracteres únicos em ASCII.\nNo UTF-8, qualquer caractere Unicode pode ser traduzido para uma sequência de números binários e vice-versa. É dessa forma que surge o nome \u0026ldquo;formato de transformação unicode\u0026rdquo;, isto é, Unicode Transformation Format. Cada unidade de código é composto por 8 bits (1 byte) e, assim, temos o 8-bit Unicode Transformation Format.\nDiferentemente do ASCII, até quatro unidades de código (4 bytes) podem ser utilizadas para representar um caractere, isto é, sua forma decodificada. Até quatro unidades porque a quantidade é dinâmica, \u0026ldquo;poupando\u0026rdquo; espaço quando possível. Por outro lado, a forma codificada (o que chamamos de code point) é totalmente definida em termos do padrão de codificação Unicode especificado. O code point é um valor inteiro, especificado de acordo com uma representação hexadecimal. Assim, existem 1,114,112 code points (de $0$ a $10FFFF$ ou $17\\cdot16^{4}$) divididos em até 17 planos, que correspondem ao prefixo de $0$ a $10$ em notação hexadecimal.\nPor exemplo, o caractere \u0026ldquo;A\u0026rdquo; é representado pelo code point U+0041 (U+número hexadecimal do code point) e tem a representação binária 01000001 (1 byte). Enquanto isso, o caractere \u0026ldquo;あ\u0026rdquo; do alfabeto japonês hiragana \u0026ndash; que também se lê \u0026ldquo;a\u0026rdquo; \u0026ndash; é representado pelo code point U+3042 e tem representação binária de três bytes: 11100011, 10000001 e 10000010.\nOs primeiros 256 caracteres da biblioteca Unicode são aqueles presentes no ASCII, estes representados apenas por um byte. Portanto, a biblioteca ASCII é um sub-conjunto do UTF-8 e textos em ASCII têm compatibilidade com textos em UTF-8.\nPadrões:\nO código no core da distribuição Python deve sempre usar UTF-8 (ou ASCII na versão Python 2);\nArquivos usando ASCII (em Python 2) ou UTF-8 (em Python 3) não devem ter uma declaração de encoding;\nNas bibliotecas padrões, encodings não-padrões devem ser usadas apenas com propósito de teste, ou quando um comentário/docstring precisa mencionar um nome de autor que contém caracteres não-ASCII; caso contrário, preferencialmente inclui-se dados não-ASCII por meio dos escapes \\x, \\u, \\U ou \\N;\nPara versões de Python acima da 3.0, os identificadores (nome dado a classes, funcões, variáveis etc) devem conter apenas caracteres ASCII e usar palavras em inglês sempre que possível (em vários casos, abreviações e termos técnicos são usados e não são em inglês). Além disso, strings e comentários também devem estar em ASCII. As exceções são as seguintes: (a) em caso de teste de features não-ASCII; (b) nome de autores. Autores cujos nomes não são baseados no alfabeto latino (set de caracteres latin-1, ISO/IEC 8859-1) devem fornecer uma transliteração dos nomes em ASCII;\nProjetos open source com público global são encorajados a adotar políticas similares.\nImports Padrões\nOs imports de bibliotecas devem estar em linhas separadas: # Correto. import os import sys # Errado. import os, sys Porém, pode-se fazer:\nfrom subprocess import Popen, PIPE Os imports devem ser colocados sempre no topo do arquivo, logo depois de qualquer comentário do módulo ou docstrings, e antes de variáveis globais ou constantes do módulo. Em geral, devem ser agrupados na seguinte ordem:\nImports da biblioteca padrão; Imports de programas de terceiros; Imports de aplicações locais/bibliotecas específicas. Deve haver uma linha branca separando cada grupo.\nImports absolutos \u0026ndash; especificando o caminho inteiro até o pacote \u0026ndash; são recomendados, porque eles geralmente são mais legíveis e tendem a se comportar melhor (ou ao menos dar mensagens de erro melhores) se o sistema de importação estiver configurado incorretamente (como quando um diretório dente do pacote acaba no sys.path): import mypkg.sibling from mypkg import sibling from mypkg.sibling import example Porém, imports relativos explícitos \u0026ndash; especificando o caminho relativo da posição atual até o pacote \u0026ndash; são uma alternativa aceitável a imports absolutos, especialmente quando se lida com layouts complexos de pacotes quando o uso de imports absolutos seria desnecessariamente prolixo:\nfrom . import sibling from .sibling import example Código de bibliotecas padrões deve sempre evitar layouts complexos de pacotes e sempre usar imports absolutos.\nImports relativos implícitos nunca devem ser utilizados e foram removidos do Python 3.\nReferências [1] PEP 1 \u0026ndash; PEP Purpose and Guidelines.\n[2] PEP 8 \u0026ndash; Style Guide for Python Code.\nWhat is UTF-8 Encoding? A Guide for Non-Programmers\nWhat\u0026rsquo;s the difference between a character, a code point, a glyph and a grapheme?\n","date":1607299200,"expirydate":-62135596800,"kind":"page","lang":"pt","lastmod":1638835200,"objectID":"ef250a05a08bc327f01d61fd482c2987","permalink":"https://ansesu.github.io/post/python-pep8/","publishdate":"2020-12-07T00:00:00Z","relpermalink":"/post/python-pep8/","section":"post","summary":"Nos últimos tempos, precisei resgatar os códigos de análises que realizei durante o mestrado. Percebi que eles estão um pouco confusos e difíceis de ler. Com intuito de resolver esse problema, decidi buscar entender quais são as melhores práticas de estilo quando programando em Python.","tags":["Python","PEP8"],"title":"PEP8 - Melhores práticas de estilo em Python","type":"post"},{"authors":["Haroldo V. Ribeiro","Andre S. Sunahara","Jack Sutton","Matjaz Perc","Quentin S. Hanley"],"categories":null,"content":"","date":1600819200,"expirydate":-62135596800,"kind":"page","lang":"pt","lastmod":1600819200,"objectID":"f992302134da0ca08917c949f17e4de8","permalink":"https://ansesu.github.io/publication/2020/city-size-and-the-spreading-of-covid-19-in-brazil/","publishdate":"2020-09-23T00:00:00Z","relpermalink":"/publication/2020/city-size-and-the-spreading-of-covid-19-in-brazil/","section":"publication","summary":"The current outbreak of the coronavirus disease 2019 (COVID-19) is an unprecedented example of how fast an infectious disease can spread around the globe (especially in urban areas) and the enormous impact it causes on public health and socio-economic activities. Despite the recent surge of investigations about different aspects of the COVID-19 pandemic, we still know little about the effects of city size on the propagation of this disease in urban areas. Here we investigate how the number of cases and deaths by COVID-19 scale with the population of Brazilian cities. Our results indicate small towns are proportionally more affected by COVID-19 during the initial spread of the disease, such that the cumulative numbers of cases and deaths per capita initially decrease with population size. However, during the long-term course of the pandemic, this urban advantage vanishes and large cities start to exhibit higher incidence of cases and deaths, such that every 1% rise in population is associated with a 0.14% increase in the number of fatalities per capita after about four months since the first two daily deaths. We argue that these patterns may be related to the existence of proportionally more health infrastructure in the largest cities and a lower proportion of older adults in large urban areas. We also find the initial growth rate of cases and deaths to be higher in large cities; however, these growth rates tend to decrease in large cities and to increase in small ones over time.","tags":["COVID-19","Cities","Complex Systems"],"title":"City size and the spreading of COVID-19 in Brazil","type":"publication"},{"authors":["Andre"],"categories":null,"content":"Gostaria de deixar claro que, de maneira alguma, posso ser considerado um epidemiologista. O intuito desse post é de alguma forma poder contribuir com estimativas mais precisas para o número de reprodução em Maringá, mas conclusões devem ser tomadas mediante a utilização de uma variedade parâmetros.\nO número de reprodução é o número esperado de infecções decorrentes de um indivíduo que se tornou infeccioso no tempo $t$. Do ponto de vista da saúde pública, é de interesse que esse número permaneça abaixo do limiar epidêmico ($R=1$), o que indica que a epidemia está desacelerando. O número de reprodução básico $R_0$ é a estimativa para essa quantidade no início da epidemia, quando a população inteira está suscetível à doença. Porém, ao passo que parcela da população ganha imunidade e medidas de intervenção são tomadas, o número de reprodução básico não tem mais validade e a atenção muda para o cálculo do que chamamos de número de reprodução que varia no tempo $R(t)$. Como exemplo, é possível citar os números de reprodução instantâneo e efetivo. Como se bem sabe, nenhum modelo é perfeito visto que sempre existem suposições e hipóteses necessárias para que a modelagem seja realizada. Além disso, existe uma limitação inerente da natureza do dado que, sendo mais ou menos detalhado, impacta na qualidade do modelo. A seguir, vou discorrer um pouco sobre a implementação que fizemos desses dois modelos para o caso de Maringá e sobre a limitação de dados públicos disponíveis nesse caso.\nLista de Conteúdos Número de reprodução efetivo Número de reprodução instantâneo Resultados Recursos interessantes Referências Número de reprodução efetivo Anteriormente, no website Observatório COVID-19 Maringá, calculamos o número de reprodução instantâneo $R_{inst}(t)$ utilizando o pacote EpiEstim do R [1]. Uma breve explicação sobre esse modelo se encontra no final desta postagem. Em poucas palavras, ele estima o número de reprodução instântaneo por meio do padrão de transmissibilidade do vírus nos últimos dias. Ao acompanhar a evolução da COVID-19 em Maringá, percebemos que as estimativas desse parâmetro poderiam estar atrasadas em alguns dias. Isso acontece devido à natureza dos dados disponibilizados pela Secretaria Municipal de Saúde de Maringá, uma vez que utilizamos dados dos casos confirmados diários de COVID-19. Disso, dois principais problemas decorrem:\nPrimeiro, consideramos que o número diário de casos confirmados de COVID-19 tem a mesma interpretação de número de infecções diárias por COVID-19. No entanto, sabe-se que existe um período de incubação do vírus, um atraso da notificação e, além disso, um atraso decorrente da espera pelo resultado do teste. A data de confirmação não é igual à data de infecção do indivíduo. Assim, nossas estimativas do número de reprodução instântaneo sempre estarão atrasadas em relação ao seu valor verdadeiro; O segundo problema é que, como o volume de testes varia, é certo que estamos subestimando o número de confirmados. Esses dois problemas podem ser resolvidos utilizando o modelo do número de reprodução instantâneo aliado a técnicas de nowcasting [2] e correções no número de confirmados pelo volume de testagem. Porém, para isso, seriam necessários dados de atraso para todos os confirmados e de volume de testagem diária, o que não temos. A alternativa que aqui apresento realiza essas correções de maneira unificada, isto é, por meio de um único processo que engloba todas essas considerações. Além disso, ela relaxa a necessidade de possuir a integridade dos dados de atraso de notificação. Com esse intuito, consideramos que o atraso pode ser aproximadamente constante no tempo e estimado por informações retiradas de outra base de dados. Recorremos ao método utilizado pelo website rt.live para o cálculo do número de reprodução efetivo $R_{ef}(t)$. Diferentemente do número de reprodução instantâneo, estimativas do número de reprodução efetivo advêm de simulações da epidemia como um todo, e não utilizam apenas os dados dos últimos dias. Dessa forma, o modelo pode ser denominado generativo, pois gera a curva de contágio desde o início da epidemia. Inicialmente, supomos que o número de reprodução $R_{ef}(t)$ caminha aleatoriamente, isto é, $$ \\log R_{ef}(t) \\sim \\mathcal{N}[R_{ef}(t-1), \\sigma=0.1]\\ , $$ em que $\\sigma$ indica o quão rapidamente o número de reprodução pode variar diariamente. Além disso, supomos que existem uma parcela de indivíduos que iniciam a epidemia e estão distribuídos como $$ \\text{Primeiros infectados} \\sim Exp(\\lambda=50)\\ . $$ A partir disso, podemos simular a epidemia por meio da relação $$ I(t) = R_{ef}(t)\\sum_s I(t-s)w(s)\\ , $$ sendo $I(t)$ o número de infectados no tempo $t$, $w(s)$ a distribuição de probabilidade do intervalo de tempo de geração e $s$ o número de dias anteriores. A distribuição de probabilidade $w(s)$ é a distribuição da diferença das datas de infecção entre casos primários e secundários. Utilizamos as estimativas de Nishiura et al. [3] para gerar a distribuição $w(s)$ com média $\\mu=4.7$ dias e desvio padrão $\\sigma=2.9$ dias, como utilizados no rt.live. O primeiro erro do modelo utilizado anteriormente foi considerar que $I(t)$ é o número de infectados diários, mas, na verdade, utilizamos dados de confirmados diários. Temos estimativas para o tempo de incubação do vírus ($\\approx$ 5 dias [4]) e para o atraso do resultado do teste ($\\approx$ 2 dias). Para incorporar o atraso da notificação, utilizamos informações do banco de dados SRAG 2020 disponibilizados pelo DATASUS. A Síndrome Respiratória Aguda Grave (SRAG) é um conjunto de sintomas (febre, tosse/dor de garganta, dispineia/saturação de oxigênio/desconforto respiratório) e tem notificação obrigatória no Sistema de Informação da Vigilância Epidemiológia da Gripe (SIVEP-Gripe). Esse sistema existe desde 2009 e foi criado com intuito de coletar informações sobre SRAG na epidemia de H1N1. O preenchimento é realizado através de uma ficha cadastral que inclui dados como data de primeiro sintomas e data de notificação. Recentemente, em 21/03/2020, o SARS-CoV-2 passou a integrar o painel de vírus testados para casos de SRAG. Utilizamos os dados de casos positivados de COVID-19 em Maringá nesse banco de dados para estimar o atraso entre os primeiros sintomas e a notificação do caso. Consideramos, aqui, que o atraso de notificação é constante no tempo (uma hipótese importante). Em outras palavras, consideramos que, desde o começo da epidemia até hoje, os casos têm o mesmo atraso de notificação. Além disso, o dado que possuímos é parcial, pois nem todos os casos de COVID-19 evoluem para SRAG, mas consideramos que é uma aproximação razoável. Uma melhor solução seria utilizar a base de dados integral para todos os casos confirmados na cidade se estes fossem disponibilizados pela Secretaria de Saúde, porém, este não é o caso. A partir do banco de dados SRAG 2020, do tempo de incubação do vírus e do atraso da testagem, estimamos uma distribuição de probabilidade que denominaremos $h(s)$ sendo $s$ o número de dias anteriores à confirmação do caso. A partir dessa distribuição, realizamos uma convolução para estimar a data de infecção dos casos, ou seja, $$ I(t) = I_{c}(t)*h(s)\\ , $$ em que $I_{c}(t)$ o número de casos confirmados no tempo $t$.\nO segundo problema (de testagem) pode ser contornado utilizando uma distribuição binomial negativa com um parâmetro de exposição para cada dia. A distribuição binomial negativa é mais flexível que uma distribuição de Poisson, pois permite que a variabilidade seja diferente do parâmetro de localização do modelo. O parâmetro de exposição, por sua vez, leva em consideração as diferentes taxas de testagem diárias. Em outras palavras, ajustamos o número de casos pela quantidade de \u0026ldquo;oportunidade\u0026rdquo; que um evento possui. Para entender melhor, considere que a taxa possa ser escrita como $$ \\text{taxa} = \\dfrac{\\text{contagem}}{\\text{exposição}}\\ . $$ Para ser mais didático, considere que duas pessoas frequentam determinado hospital. Uma delas frequenta 3 vezes por semana e a outra 3 vezes por ano. É evidente que as taxas são diferentes, pois estão em escalas de tempo diferentes, apesar de a contagem de idas ao hospital ser a mesma. Dessa maneira, precisamos considerar a contagem levando em consideração a exposição, para isso, reescrevemos a equação anterior como $$ \\text{contagem} = \\text{taxa}\\cdot\\text{exposição}\\ . $$ No caso da COVID-19, a exposição é a quantidade de testes diários. Se há mais testes, é claro que possivelmente o número de casos confirmados deve ser maior. Incorporando essa informação ao modelo temos que o número de infectados pode ser escrito como $$ I(t) \\sim NegBin(\\mu, \\alpha)\\ , $$ $$ \\mu = I(t) \\cdot \\text{exposição}\\ , $$ $$ \\alpha \\sim Gamma(\\mu=6,\\sigma=1)\\ , $$ de acordo com esta definição da distribuição binomial negativa. O número de testes diários foi estimado utilizando dados dos boletins diários de acordo com a relação: $$ \\text{testes} = \\text{número de confirmados diário} + \\text{número de encerrados diário}\\ . $$ Completamos os dados de testagem anteriores à data de 31/03/2020 supondo que havia uma frequência uniforme de trinta testes diários, uma vez que esses dados não estavam disponíveis à época.\nComo já mencionamos, este modelo difere daquele para o número de reprodução instantâneo, pois gera a curva inteira de infecção de acordo com os dados e, assim, tem como condição que a curva seja quasi-contínua. Estimativas com novos dados diários mudam as estimativas de datas anteriores e, ao atualizar todas as estimativas com novas informações, considero que é um modelo que pode ser considerado mais honesto. Além disso, incorporamos as soluções para os dois problemas anteriormente constatados. Dessa forma, o número de reprodução estimado deve representar a situação atual de infectividade da COVID-19 de maneira mais próxima da realidade. Amostramos esse modelo utilizando o pacote PyMC3 do Python.\nNúmero de reprodução instantâneo Como mencionado anteriormente, o número de reprodução básico $R_0$ do modelo SIR é uma propriedade da fase inicial da epidemia e indica o número de casos secundários médio que decorrem de um indivíduo infectado. Nesse período inicial, existe um regime exponencial de crescimento para o número de infectados $I(t)$. No entanto, em estágios mais avançados da epidemia, essa suposição não é mais verdadeira, sendo necessária a adoção de modelos alternativos. Uma opção é a escolha de abordagens que levam em conta o perfil de infectividade dos contaminados, também conhecidos como modelos time-since-infection [5]. A partir deles, é possível calcular o número de reprodução instantaneamente no tempo $t$, que apresenta a mesma interpretação do número de reprodução básico, porém tem validade para qualquer momento da epidemia. Para isso, podemos modelar a transmissão de COVID-19 como um processo de Poisson por meio de uma abordagem Bayesiana. O número de reprodução instantâneo pode ser descrito como $$ R_{inst}(t) = \\dfrac{I(t)}{\\sum_{s=1}^{\\tau} I(t-s)w(s)}\\ , $$ em que $w(s)$ é o perfil de infectividade, ou distribuição do tempo de geração, e $\\tau$ é a janela temporal considerada para estimar o $R_{inst}(t)$, considerando que o número de reprodução instantâneo permanece constante no intervalo $[t-\\tau+1, t]$. O perfil de infectividade $w(s)$ é uma distribuição de probabilidade que depende do tempo desde a infecção por COVID-19. Dessa forma, maiores valores de $w(s)$ indicam que os infectados $I(t-s)$ estão mais suscetíveis a transmitir a doença nesse período. A distribuição $w(s)$ depende apenas em fatores biológicos individuais como características do vírus e severidade dos sintomas [1]. Dessa maneira, o número de reprodução instantâneo $R_{inst}(t)$ como calculado na equação acima equivale ao número médio de casos gerados pelos infectados na janela de $\\tau$ dias anteriores. A verossimilhança para $I(t)$ pode ser escrita como uma distribuição de Poisson, isto é, $$ \\mathcal{L}[I(t)| I(t-\\tau+1),\\dots,I(t-1), w, R_{inst}(t)] = \\dfrac{[R_{inst}(t)\\Lambda(t)]^{I(t)}e^{R_{inst}(t)\\Lambda(t)}}{I(t)!}\\ , $$ em que $$ \\Lambda(t)=\\sum_{s=1}^{\\tau}I(t-s)w(s)\\ . $$ Dessa forma, supondo independência estatística entre os períodos, a verossimilhança dentro da janela $\\tau$ pode ser escrita como $$ \\mathcal{L}[I(t-\\tau+1),\\dots,I(t)| w, R_{inst}(t)] = \\prod_{s=t-\\tau+1}^{t} \\dfrac{[R_{inst}(t)\\Lambda(s)]^{I(s)}e^{-R_{inst}(t)\\Lambda(s)}}{I(s)}\\ . $$ Usando o teorema de Bayes, podemos calcular a distribuição a posteriori para estimar $R_{inst}(t)$, isto é, $$ P[R_{inst}(t),I(t-\\tau+1),\\dots,I(t)| w ] \\propto \\mathcal{L}[I(t-\\tau+1),\\dots,I(t)| R_{inst}(t), w ] P[R_{inst}(t)]\\ . $$ Seguindo o procedimento proposto pelos sites epiforecasts.io e covid19br, consideramos que o perfil de infectividade é uma distribuição Gamma com média de 4.8 dias e desvio padrão de 2.3 dias, valores estimados em [3] e utilizados por esses dois sites. Além disso, atribuímos incerteza ao perfil de infectividade amostrando a média e o desvio padrão de distribuições normais truncadas centradas nos valores descritos anteriormente para um total de 500 repetições. Consideramos que $R_{inst}(t)$ apresenta uma distribuição Gamma como priori, com média 2.6 e desvio padrão 2, o que leva em consideração estimativas do número de reprodução básico em Wuhan no começo da epidemia [6]. Por fim, para a janela temporal $\\tau$, adotamos o tempo $\\tau=7$ dias uma vez que a série temporal de casos por COVID-19 aparenta uma periodicidade semanal. Aplicamos esse modelo utilizando o pacote EpiEstim do R.\nSó lembrando: nesse modelo, consideramos que o número de infectados diário apresenta a mesma interpretação do número de confirmados diário. Sabemos, porém, que existe um atraso na confirmação dos casos. Desde o dia em que a pessoa é infectada, leva-se um tempo para o vírus incubar (cerca de cinco dias) e os sintomas se manifestarem. Além disso, também pode existir um atraso de notificação e de espera pelos resultados dos testes. Esses problemas seriam resolvidos se tivéssemos os dados referentes ao atraso de notificação e de data do começo dos sintomas para cada caso confirmado, a fim de realizar medidas de nowcasting [2]. Além disso, o modelo não leva em consideração o volume de testagem variável (isto é, que o número de testes varia diariamente), o que pode causar uma subestimação do número de reprodução instantâneo. Ainda assim, acredito que as estimativas do número de reprodução instantâneo podem transmitir informações importantes sobre o avanço da epidemia (mesmo que com atraso). Diferentemente do número de reprodução efetivo, as estimativas são mais sensíveis às variações mais recentes dos números de casos confirmados diários uma vez que não existe a condição de que a curva seja quasi-contínua.\nResultados As figuras abaixo mostram, respectivamente, estimativas para o número de reprodução efetivo $R_{ef}(t)$ e instantâneo $R_{inst}(t)$ seguindo os procedimentos aqui descritos.\nFigura: evolução temporal do $R_{ef}(t)$ em Maringá. Figura: evolução temporal do $R_{inst}(t)$ em Maringá., A figura abaixo mostra a evolução temporal das variáveis presentes no modelo generativo: i) o número de confirmados (em cinza); ii) o número de confirmados esperado (em verde); iii) o número de confirmados esperado supondo testagem uniforme (em laranja); iv) o número de infectados esperado (em roxo).\nFigura: evolução temporal das variáveis presentes no modelo generativo em Maringá. O código para reprodução dessa análise está disponível em ansesu/rt_livemaringa. O código-base e maiores detalhes sobre o modelo podem ser encontrados no repositório original rtcovidlive/covid-model.\nRecursos interessantes Hospitalizações por SRAG como proxy para casos graves de Covid-19 no Brasil\nrt.live\nepiforecasts\nObservatório COVID-19 BR\nReferências [1] A. Cori, N. M. Ferguson, C. Fraser, S. Cauchemez, A New Framework and Software to Estimate Time-Varying Reproduction Numbers During Epidemics. American Journal of Epidemiology 178, 1505\u0026ndash;1512 (2013).\n[2] L. S. Bastos, T. Economou, M. F. C. Gomes, D. A. M. Villela, F. C. Coelho, O. G. Cruz, O. S. T. Bailey, C. T. Codeço, A modelling approach for correcting reporting delays in disease surveillance data. Statistics in Medicine 38, 4363-4377 (2019)\n[3] H. Nishiura, N.M. Linton, A.R. Akhmetzhanov, Serial interval of novel coronavirus (COVID-19) infections. International Journal of Infectious Diseases 93, 284-286 (2020).\n[4] S. A. Lauer, K. H. Grantz, Q. Bi, F. K. Jones, Q. Zheng, H. R. Meredith, A. S. Azman, N. G. Reich, J. Lessler, The incubation period of coronavirus disease 2019 (COVID-19) from publicly reported confirmed cases: Estimation and application. Annals of Internal Medicine 172, 577-582 (2020).\n[5] C. Fraser, Estimating Individual and Household Reproduction Numbers in an Emerging Epidemic. PLOS ONE 2(8), e758 (2007).\n[6] S. Abbott, J. Hellewell, J. Munday, S. Funk, The transmissibility of novel Coronavirus in the early stages of the 2019-20 outbreak in Wuhan: Exploring initial point-source exposure sizes and durations using scenario analysis. Wellcome Open Research 5, 17 (2020).\n","date":1594080000,"expirydate":-62135596800,"kind":"page","lang":"pt","lastmod":1594080000,"objectID":"e4102ef4917277286dc9f4323926b3ad","permalink":"https://ansesu.github.io/post/rt-live-maringa/","publishdate":"2020-07-07T00:00:00Z","relpermalink":"/post/rt-live-maringa/","section":"post","summary":"Gostaria de deixar claro que, de maneira alguma, posso ser considerado um epidemiologista. O intuito desse post é de alguma forma poder contribuir com estimativas mais precisas para o número de reprodução em Maringá, mas conclusões devem ser tomadas mediante a utilização de uma variedade parâmetros.","tags":["Número de reprodução","COVID-19","Maringá","Python","R","Visualização"],"title":"Uma alternativa para o cálculo do número de reprodução em Maringá","type":"post"},{"authors":null,"categories":null,"content":"Tesestrete\n","date":1593734400,"expirydate":-62135596800,"kind":"page","lang":"pt","lastmod":1593734400,"objectID":"bdefae70dcd0936346064f2cf1971c6b","permalink":"https://ansesu.github.io/project/observatorio-covid/","publishdate":"2020-07-03T00:00:00Z","relpermalink":"/project/observatorio-covid/","section":"project","summary":"Acompanhando a evolução da COVID-19 em Maringá","tags":["COVID-19","Maringá"],"title":"Observatório COVID-19 Maringá","type":"project"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"pt","lastmod":-62135596800,"objectID":"6d99026b9e19e4fa43d5aadf147c7176","permalink":"https://ansesu.github.io/contact/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/contact/","section":"","summary":"","tags":null,"title":"Contato","type":"widget_page"},{"authors":null,"categories":null,"content":"Galeria de fotos aaaaaaa Galeria de vídeos Final de tarde em Tokyo - 2014\nJamming in Sakae - Nagoya - 2014\nJamming in Sakae - Nagoya - 2014\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"pt","lastmod":-62135596800,"objectID":"665288c8761d48eb3366c37954243edc","permalink":"https://ansesu.github.io/gallery/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/gallery/","section":"","summary":"Galeria de fotos aaaaaaa Galeria de vídeos Final de tarde em Tokyo - 2014\nJamming in Sakae - Nagoya - 2014\nJamming in Sakae - Nagoya - 2014","tags":null,"title":"Galeria","type":"page"}]